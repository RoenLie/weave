{"version":3,"file":"search-worker.js","sources":["../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/tokenizer/languages.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/utils.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/errors.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/defaults.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/internal-document-id-store.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/documents-store.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/plugins.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/hooks.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/trees/avl.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/trees/flat.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/levenshtein.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/trees/radix.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/trees/bkd.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/algorithms.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/cosine-similarity.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/index.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/sorter.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/tokenizer/diacritics.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/tokenizer/english-stemmer.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/tokenizer/index.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/methods/create.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/constants.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/filters.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/facets.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/components/groups.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/methods/search-fulltext.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/methods/search-vector.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/methods/search-hybrid.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/methods/search.js","../../../../node_modules/.pnpm/@orama+orama@2.0.1/node_modules/@orama/orama/dist/methods/serialization.js","../../src/workers/search-worker.ts"],"sourcesContent":["export const STEMMERS = {\n    arabic: 'ar',\n    armenian: 'am',\n    bulgarian: 'bg',\n    danish: 'dk',\n    dutch: 'nl',\n    english: 'en',\n    finnish: 'fi',\n    french: 'fr',\n    german: 'de',\n    greek: 'gr',\n    hungarian: 'hu',\n    indian: 'in',\n    indonesian: 'id',\n    irish: 'ie',\n    italian: 'it',\n    lithuanian: 'lt',\n    nepali: 'np',\n    norwegian: 'no',\n    portuguese: 'pt',\n    romanian: 'ro',\n    russian: 'ru',\n    serbian: 'rs',\n    slovenian: 'ru',\n    spanish: 'es',\n    swedish: 'se',\n    tamil: 'ta',\n    turkish: 'tr',\n    ukrainian: 'uk',\n    sanskrit: 'sk'\n};\nexport const SPLITTERS = {\n    dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,\n    italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n    norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,\n    portuguese: /[^a-z0-9à-úÀ-Ú]/gim,\n    russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,\n    spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,\n    swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,\n    german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,\n    finnish: /[^a-z0-9äöÄÖ]+/gim,\n    danish: /[^a-z0-9æøåÆØÅ]+/gim,\n    hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,\n    romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,\n    serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,\n    turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,\n    lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,\n    arabic: /[^a-z0-9أ-ي]+/gim,\n    nepali: /[^a-z0-9अ-ह]+/gim,\n    irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,\n    indian: /[^a-z0-9अ-ह]+/gim,\n    armenian: /[^a-z0-9ա-ֆ]+/gim,\n    greek: /[^a-z0-9α-ωά-ώ]+/gim,\n    indonesian: /[^a-z0-9]+/gim,\n    ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,\n    slovenian: /[^a-z0-9čžšČŽŠ]+/gim,\n    bulgarian: /[^a-z0-9а-яА-Я]+/gim,\n    tamil: /[^a-z0-9அ-ஹ]+/gim,\n    sanskrit: /[^a-z0-9A-Zāīūṛḷṃṁḥśṣṭḍṇṅñḻḹṝ]+/gim\n};\nexport const SUPPORTED_LANGUAGES = Object.keys(STEMMERS);\n\n//# sourceMappingURL=languages.js.map","import { createError } from './errors.js';\nconst baseId = Date.now().toString().slice(5);\nlet lastId = 0;\nconst k = 1024;\nconst nano = BigInt(1e3);\nconst milli = BigInt(1e6);\nconst second = BigInt(1e9);\nexport const isServer = typeof window === 'undefined';\n/**\n * This value can be increased up to 100_000\n * But i don't know if this value change from nodejs to nodejs\n * So I will keep a safer value here.\n */ export const MAX_ARGUMENT_FOR_STACK = 65535;\n/**\n * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301\n * that issue is caused because the array that is pushed is huge (>100k)\n *\n * @example\n * ```ts\n * safeArrayPush(myArray, [1, 2])\n * ```\n */ export function safeArrayPush(arr, newArr) {\n    if (newArr.length < MAX_ARGUMENT_FOR_STACK) {\n        Array.prototype.push.apply(arr, newArr);\n    } else {\n        for(let i = 0; i < newArr.length; i += MAX_ARGUMENT_FOR_STACK){\n            Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));\n        }\n    }\n}\nexport function sprintf(template, ...args) {\n    return template.replace(/%(?:(?<position>\\d+)\\$)?(?<width>-?\\d*\\.?\\d*)(?<type>[dfs])/g, function(...replaceArgs) {\n        const groups = replaceArgs[replaceArgs.length - 1];\n        const { width: rawWidth , type , position  } = groups;\n        const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();\n        const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth);\n        switch(type){\n            case 'd':\n                return replacement.toString().padStart(width, '0');\n            case 'f':\n                {\n                    let value = replacement;\n                    const [padding, precision] = rawWidth.split('.').map((w)=>Number.parseFloat(w));\n                    if (typeof precision === 'number' && precision >= 0) {\n                        value = value.toFixed(precision);\n                    }\n                    return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString();\n                }\n            case 's':\n                return width < 0 ? replacement.toString().padEnd(-width, ' ') : replacement.toString().padStart(width, ' ');\n            default:\n                return replacement;\n        }\n    });\n}\nexport async function formatBytes(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return '0 Bytes';\n    }\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = [\n        'Bytes',\n        'KB',\n        'MB',\n        'GB',\n        'TB',\n        'PB',\n        'EB',\n        'ZB',\n        'YB'\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n}\nexport function isInsideWebWorker() {\n    // @ts-expect-error - WebWorker global scope\n    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n}\nexport function isInsideNode() {\n    return typeof process !== 'undefined' && process.release && process.release.name === 'node';\n}\nexport function getNanosecondTimeViaPerformance() {\n    return BigInt(Math.floor(performance.now() * 1e6));\n}\nexport async function formatNanoseconds(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < nano) {\n        return `${value}ns`;\n    } else if (value < milli) {\n        return `${value / nano}μs`;\n    } else if (value < second) {\n        return `${value / milli}ms`;\n    }\n    return `${value / second}s`;\n}\nexport async function getNanosecondsTime() {\n    if (isInsideWebWorker()) {\n        return getNanosecondTimeViaPerformance();\n    }\n    if (isInsideNode()) {\n        return process.hrtime.bigint();\n    }\n    if (typeof process !== 'undefined' && process.hrtime !== undefined) {\n        return process.hrtime.bigint();\n    }\n    if (typeof performance !== 'undefined') {\n        return getNanosecondTimeViaPerformance();\n    }\n    // @todo: fallback to V8 native method to get microtime\n    return BigInt(0);\n}\nexport async function uniqueId() {\n    return `${baseId}-${lastId++}`;\n}\nexport function getOwnProperty(object, property) {\n    // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n    if (Object.hasOwn === undefined) {\n        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\n    }\n    return Object.hasOwn(object, property) ? object[property] : undefined;\n}\nexport function getTokenFrequency(token, tokens) {\n    let count = 0;\n    for (const t of tokens){\n        if (t === token) {\n            count++;\n        }\n    }\n    return count;\n}\nexport function insertSortedValue(arr, el, compareFn = sortTokenScorePredicate) {\n    let low = 0;\n    let high = arr.length;\n    let mid;\n    while(low < high){\n        mid = low + high >>> 1;\n        if (compareFn(el, arr[mid]) < 0) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    arr.splice(low, 0, el);\n    return arr;\n}\nexport function sortTokenScorePredicate(a, b) {\n    if (b[1] === a[1]) {\n        return a[0] - b[0];\n    }\n    return b[1] - a[1];\n}\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect(arrays) {\n    if (arrays.length === 0) {\n        return [];\n    } else if (arrays.length === 1) {\n        return arrays[0];\n    }\n    for(let i = 1; i < arrays.length; i++){\n        if (arrays[i].length < arrays[0].length) {\n            const tmp = arrays[0];\n            arrays[0] = arrays[i];\n            arrays[i] = tmp;\n        }\n    }\n    const set = new Map();\n    for (const elem of arrays[0]){\n        set.set(elem, 1);\n    }\n    for(let i = 1; i < arrays.length; i++){\n        let found = 0;\n        for (const elem of arrays[i]){\n            const count = set.get(elem);\n            if (count === i) {\n                set.set(elem, count + 1);\n                found++;\n            }\n        }\n        if (found === 0) return [];\n    }\n    return arrays[0].filter((e)=>{\n        const count = set.get(e);\n        if (count !== undefined) set.set(e, 0);\n        return count === arrays.length;\n    });\n}\nexport async function getDocumentProperties(doc, paths) {\n    const properties = {};\n    const pathsLength = paths.length;\n    for(let i = 0; i < pathsLength; i++){\n        const path = paths[i];\n        const pathTokens = path.split('.');\n        let current = doc;\n        const pathTokensLength = pathTokens.length;\n        for(let j = 0; j < pathTokensLength; j++){\n            current = current[pathTokens[j]];\n            // We found an object but we were supposed to be done\n            if (typeof current === 'object') {\n                if (current !== null && 'lat' in current && 'lon' in current && typeof current.lat === 'number' && typeof current.lon === 'number') {\n                    current = properties[path] = current;\n                    break;\n                } else if (!Array.isArray(current) && current !== null && j === pathTokensLength - 1) {\n                    current = undefined;\n                    break;\n                }\n            } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {\n                // We can't recurse anymore but we were supposed to\n                current = undefined;\n                break;\n            }\n        }\n        if (typeof current !== 'undefined') {\n            properties[path] = current;\n        }\n    }\n    return properties;\n}\nexport async function getNested(obj, path) {\n    const props = await getDocumentProperties(obj, [\n        path\n    ]);\n    return props[path];\n}\nexport function flattenObject(obj, prefix = '') {\n    const result = {};\n    for(const key in obj){\n        const prop = `${prefix}${key}`;\n        const objKey = obj[key];\n        if (typeof objKey === 'object' && objKey !== null) {\n            Object.assign(result, flattenObject(objKey, `${prop}.`));\n        } else {\n            result[prop] = objKey;\n        }\n    }\n    return result;\n}\nconst mapDistanceToMeters = {\n    cm: 0.01,\n    m: 1,\n    km: 1000,\n    ft: 0.3048,\n    yd: 0.9144,\n    mi: 1609.344\n};\nexport function convertDistanceToMeters(distance, unit) {\n    const ratio = mapDistanceToMeters[unit];\n    if (ratio === undefined) {\n        throw new Error(createError('INVALID_DISTANCE_SUFFIX', distance).message);\n    }\n    return distance * ratio;\n}\nexport function removeVectorsFromHits(searchResult, vectorProperties) {\n    searchResult.hits = searchResult.hits.map((result)=>({\n            ...result,\n            document: {\n                ...result.document,\n                // Remove embeddings from the result\n                ...vectorProperties.reduce((acc, prop)=>{\n                    const path = prop.split('.');\n                    const lastKey = path.pop();\n                    let obj = acc;\n                    for (const key of path){\n                        obj[key] = obj[key] ?? {};\n                        obj = obj[key];\n                    }\n                    obj[lastKey] = null;\n                    return acc;\n                }, result.document)\n            }\n        }));\n}\n\n//# sourceMappingURL=utils.js.map","import { SUPPORTED_LANGUAGES } from './components/tokenizer/languages.js';\nimport { sprintf } from './utils.js';\nconst allLanguages = SUPPORTED_LANGUAGES.join('\\n - ');\nconst errors = {\n    NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',\n    LANGUAGE_NOT_SUPPORTED: `Language \"%s\" is not supported.\\nSupported languages are:\\n - ${allLanguages}`,\n    INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,\n    MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the \"%s\" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/open-source/text-analysis/stemming for more information.`,\n    CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',\n    UNSUPPORTED_COMPONENT: `Unsupported component \"%s\".`,\n    COMPONENT_MUST_BE_FUNCTION: `The component \"%s\" must be a function.`,\n    COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component \"%s\" must be a function or an array of functions.`,\n    INVALID_SCHEMA_TYPE: `Unsupported schema type \"%s\" at \"%s\". Expected \"string\", \"boolean\" or \"number\" or array of them.`,\n    DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type \"string\". Got \"%s\" instead.`,\n    DOCUMENT_ALREADY_EXISTS: `A document with id \"%s\" already exists.`,\n    DOCUMENT_DOES_NOT_EXIST: `A document with id \"%s\" does not exists.`,\n    MISSING_DOCUMENT_PROPERTY: `Missing searchable property \"%s\".`,\n    INVALID_DOCUMENT_PROPERTY: `Invalid document property \"%s\": expected \"%s\", got \"%s\"`,\n    UNKNOWN_INDEX: `Invalid property name \"%s\". Expected a wildcard string (\"*\") or array containing one of the following properties: %s`,\n    INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,\n    INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,\n    SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on \"%s\" property.`,\n    INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type \"%s\" at \"%s\". Expected \"string\" or \"number\".`,\n    CANNOT_SORT_BY_ARRAY: `Cannot configure sort for \"%s\" because it is an array (%s).`,\n    UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field \"%s\". Allowed fields: %s`,\n    SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.oramasearch for more information.`,\n    UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property \"%s\".`,\n    INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property \"%s\". Allowed types: \"%s\", but given \"%s\".`,\n    UNKNOWN_FILTER_PROPERTY: `Unknown filter property \"%s\".`,\n    INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got \"%s\" instead.`,\n    INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got \"%s\" instead.`,\n    INVALID_INPUT_VECTOR: `Property \"%s\" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,\n    WRONG_SEARCH_PROPERTY_TYPE: `Property \"%s\" is not searchable. Only \"string\" properties are searchable.`,\n    FACET_NOT_SUPPORTED: `Facet doens't support the type \"%s\".`,\n    INVALID_DISTANCE_SUFFIX: `Invalid distance suffix \"%s\". Valid suffixes are: cm, m, km, mi, yd, ft.`,\n    INVALID_SEARCH_MODE: `Invalid search mode \"%s\". Valid modes are: \"fulltext\", \"vector\", \"hybrid\".`,\n    MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,\n    MISSING_TERM: `\"term\" is a required parameter when performing hybrid search. Please provide a search term.`,\n    INVALID_VECTOR_INPUT: `Invalid \"vector\" property. Expected an object with \"value\" and \"property\" properties, but got \"%s\" instead.`,\n    PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`\n};\nexport function createError(code, ...args) {\n    const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args));\n    error.code = code;\n    if ('captureStackTrace' in Error.prototype) {\n        Error.captureStackTrace(error);\n    }\n    return error;\n}\n\n//# sourceMappingURL=errors.js.map","import { createError } from '../errors.js';\nimport { formatNanoseconds, uniqueId } from '../utils.js';\nexport { getDocumentProperties } from '../utils.js';\nexport async function formatElapsedTime(n) {\n    return {\n        raw: Number(n),\n        formatted: await formatNanoseconds(n)\n    };\n}\nexport async function getDocumentIndexId(doc) {\n    if (doc.id) {\n        if (typeof doc.id !== 'string') {\n            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);\n        }\n        return doc.id;\n    }\n    return await uniqueId();\n}\nexport async function validateSchema(doc, schema) {\n    for (const [prop, type] of Object.entries(schema)){\n        const value = doc[prop];\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        if (type === 'geopoint' && typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number') {\n            continue;\n        }\n        if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n            continue;\n        }\n        if (type === 'enum[]' && Array.isArray(value)) {\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (isVectorType(type)) {\n            const vectorSize = getVectorSize(type);\n            if (!Array.isArray(value) || value.length !== vectorSize) {\n                throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);\n            }\n            continue;\n        }\n        if (isArrayType(type)) {\n            if (!Array.isArray(value)) {\n                return prop;\n            }\n            const expectedType = getInnerType(type);\n            const valueLength = value.length;\n            for(let i = 0; i < valueLength; i++){\n                if (typeof value[i] !== expectedType) {\n                    return prop + '.' + i;\n                }\n            }\n            continue;\n        }\n        if (typeof type === 'object') {\n            if (!value || typeof value !== 'object') {\n                return prop;\n            }\n            // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n            const subProp = await validateSchema(value, type);\n            if (subProp) {\n                return prop + '.' + subProp;\n            }\n            continue;\n        }\n        if (typeof value !== type) {\n            return prop;\n        }\n    }\n    return undefined;\n}\nconst IS_ARRAY_TYPE = {\n    string: false,\n    number: false,\n    boolean: false,\n    enum: false,\n    geopoint: false,\n    'string[]': true,\n    'number[]': true,\n    'boolean[]': true,\n    'enum[]': true\n};\nconst INNER_TYPE = {\n    'string[]': 'string',\n    'number[]': 'number',\n    'boolean[]': 'boolean',\n    'enum[]': 'enum'\n};\nexport function isGeoPointType(type) {\n    return type === 'geopoint';\n}\nexport function isVectorType(type) {\n    return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type);\n}\nexport function isArrayType(type) {\n    return typeof type === 'string' && IS_ARRAY_TYPE[type];\n}\nexport function getInnerType(type) {\n    return INNER_TYPE[type];\n}\nexport function getVectorSize(type) {\n    const size = Number(type.slice(7, -1));\n    switch(true){\n        case isNaN(size):\n            throw createError('INVALID_VECTOR_VALUE', type);\n        case size <= 0:\n            throw createError('INVALID_VECTOR_SIZE', type);\n        default:\n            return size;\n    }\n}\n\n//# sourceMappingURL=defaults.js.map","export function createInternalDocumentIDStore() {\n    return {\n        idToInternalId: new Map(),\n        internalIdToId: [],\n        save,\n        load\n    };\n}\nexport function save(store) {\n    return {\n        internalIdToId: store.internalIdToId\n    };\n}\nexport function load(orama, raw) {\n    const { internalIdToId  } = raw;\n    orama.internalDocumentIDStore.idToInternalId.clear();\n    orama.internalDocumentIDStore.internalIdToId = [];\n    for(let i = 0; i < internalIdToId.length; i++){\n        orama.internalDocumentIDStore.idToInternalId.set(internalIdToId[i], i + 1);\n        orama.internalDocumentIDStore.internalIdToId.push(internalIdToId[i]);\n    }\n}\nexport function getInternalDocumentId(store, id) {\n    if (typeof id === 'string') {\n        const internalId = store.idToInternalId.get(id);\n        if (internalId) {\n            return internalId;\n        }\n        const currentId = store.idToInternalId.size + 1;\n        store.idToInternalId.set(id, currentId);\n        store.internalIdToId.push(id);\n        return currentId;\n    }\n    if (id > store.internalIdToId.length) {\n        return getInternalDocumentId(store, id.toString());\n    }\n    return id;\n}\nexport function getDocumentIdFromInternalId(store, internalId) {\n    if (store.internalIdToId.length < internalId) {\n        throw new Error(`Invalid internalId ${internalId}`);\n    }\n    return store.internalIdToId[internalId - 1];\n}\n\n//# sourceMappingURL=internal-document-id-store.js.map","import { getInternalDocumentId } from './internal-document-id-store.js';\nexport async function create(_, sharedInternalDocumentStore) {\n    return {\n        sharedInternalDocumentStore,\n        docs: {},\n        count: 0\n    };\n}\nexport async function get(store, id) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id);\n    return store.docs[internalId];\n}\nexport async function getMultiple(store, ids) {\n    const found = Array.from({\n        length: ids.length\n    });\n    for(let i = 0; i < ids.length; i++){\n        const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, ids[i]);\n        found[i] = store.docs[internalId];\n    }\n    return found;\n}\nexport async function getAll(store) {\n    return store.docs;\n}\nexport async function store(store, id, doc) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id);\n    if (typeof store.docs[internalId] !== 'undefined') {\n        return false;\n    }\n    store.docs[internalId] = doc;\n    store.count++;\n    return true;\n}\nexport async function remove(store, id) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id);\n    if (typeof store.docs[internalId] === 'undefined') {\n        return false;\n    }\n    delete store.docs[internalId];\n    store.count--;\n    return true;\n}\nexport async function count(store) {\n    return store.count;\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n    const rawDocument = raw;\n    return {\n        docs: rawDocument.docs,\n        count: rawDocument.count,\n        sharedInternalDocumentStore\n    };\n}\nexport async function save(store) {\n    return {\n        docs: store.docs,\n        count: store.count\n    };\n}\nexport async function createDocumentsStore() {\n    return {\n        create,\n        get,\n        getMultiple,\n        getAll,\n        store,\n        remove,\n        count,\n        load,\n        save\n    };\n}\n\n//# sourceMappingURL=documents-store.js.map","import { createError } from '../errors.js';\nexport const AVAILABLE_PLUGIN_HOOKS = [\n    'beforeInsert',\n    'afterInsert',\n    'beforeRemove',\n    'afterRemove',\n    'beforeUpdate',\n    'afterUpdate',\n    'beforeSearch',\n    'afterSearch',\n    'beforeInsertMultiple',\n    'afterInsertMultiple',\n    'beforeRemoveMultiple',\n    'afterRemoveMultiple',\n    'beforeUpdateMultiple',\n    'afterUpdateMultiple',\n    'beforeLoad',\n    'afterLoad'\n];\nexport async function getAllPluginsByHook(orama, hook) {\n    var _orama_plugins;\n    const pluginsToRun = [];\n    const pluginsLength = (_orama_plugins = orama.plugins) === null || _orama_plugins === void 0 ? void 0 : _orama_plugins.length;\n    if (!pluginsLength) {\n        return pluginsToRun;\n    }\n    for(let i = 0; i < pluginsLength; i++){\n        try {\n            const plugin = await orama.plugins[i];\n            if (typeof plugin[hook] === 'function') {\n                pluginsToRun.push(plugin[hook]);\n            }\n        } catch (error) {\n            console.error('Caught error in getAllPluginsByHook:', error);\n            throw createError('PLUGIN_CRASHED');\n        }\n    }\n    return pluginsToRun;\n}\n\n//# sourceMappingURL=plugins.js.map","export const OBJECT_COMPONENTS = [\n    'tokenizer',\n    'index',\n    'documentsStore',\n    'sorter'\n];\nexport const FUNCTION_COMPONENTS = [\n    'validateSchema',\n    'getDocumentIndexId',\n    'getDocumentProperties',\n    'formatElapsedTime'\n];\nexport const SINGLE_OR_ARRAY_COMPONENTS = [];\nexport async function runSingleHook(hooks, orama, id, doc) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, id, doc);\n    }\n}\nexport async function runMultipleHook(hooks, orama, docsOrIds) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](orama, docsOrIds);\n    }\n}\nexport async function runAfterSearch(hooks, db, params, language, results) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language, results);\n    }\n}\nexport async function runBeforeSearch(hooks, db, params, language) {\n    const hooksLength = hooks.length;\n    for(let i = 0; i < hooksLength; i++){\n        await hooks[i](db, params, language);\n    }\n}\n\n//# sourceMappingURL=hooks.js.map","import { safeArrayPush } from '../utils.js';\nfunction rotateLeft(node) {\n    const right = node.r;\n    node.r = right.l;\n    right.l = node;\n    node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;\n    right.h = Math.max(getHeight(right.l), getHeight(right.r)) + 1;\n    return right;\n}\nfunction rotateRight(node) {\n    const left = node.l;\n    node.l = left.r;\n    left.r = node;\n    node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;\n    left.h = Math.max(getHeight(left.l), getHeight(left.r)) + 1;\n    return left;\n}\nexport function contains(node, key) {\n    return !!find(node, key);\n}\nexport function getSize(root) {\n    let size = 0;\n    const queue = [];\n    if (root !== null) {\n        queue.push(root.root);\n    }\n    while(queue.length > 0){\n        const node = queue.shift();\n        size++;\n        if (node.l !== null) {\n            queue.push(node.l);\n        }\n        if (node.r !== null) {\n            queue.push(node.r);\n        }\n    }\n    return size;\n}\nexport function isBalanced(root) {\n    if (root === null) return true;\n    const stack = [\n        root.root\n    ];\n    while(stack.length > 0){\n        const node = stack.pop();\n        if (node != null) {\n            const leftHeight = getHeight(node.l);\n            const rightHeight = getHeight(node.r);\n            const heightDiff = leftHeight - rightHeight;\n            if (Math.abs(heightDiff) > 1) {\n                return false;\n            }\n            if (node.l !== null) {\n                stack.push(node.l);\n            }\n            if (node.r !== null) {\n                stack.push(node.r);\n            }\n        }\n    }\n    return true;\n}\nexport function rangeSearch(node, min, max) {\n    const result = [];\n    function traverse(node) {\n        if (node === null) {\n            return;\n        }\n        if (min < node.k) {\n            traverse(node.l);\n        }\n        if (node.k >= min && node.k <= max) {\n            safeArrayPush(result, node.v);\n        }\n        if (max > node.k) {\n            traverse(node.r);\n        }\n    }\n    traverse(node.root);\n    return result;\n}\nexport function greaterThan(node, key, inclusive = false) {\n    const result = [];\n    function traverse(node) {\n        if (node === null) {\n            return;\n        }\n        if (inclusive && node.k >= key) {\n            safeArrayPush(result, node.v);\n        }\n        if (!inclusive && node.k > key) {\n            safeArrayPush(result, node.v);\n        }\n        traverse(node.l);\n        traverse(node.r);\n    }\n    traverse(node.root);\n    return result;\n}\nexport function lessThan(node, key, inclusive = false) {\n    const result = [];\n    function traverse(node) {\n        if (node === null) {\n            return;\n        }\n        if (inclusive && node.k <= key) {\n            safeArrayPush(result, node.v);\n        }\n        if (!inclusive && node.k < key) {\n            safeArrayPush(result, node.v);\n        }\n        traverse(node.l);\n        traverse(node.r);\n    }\n    traverse(node.root);\n    return result;\n}\nfunction getNodeByKey(node, key) {\n    while(node !== null){\n        if (key < node.k) {\n            node = node.l;\n        } else if (key > node.k) {\n            node = node.r;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}\nexport function create(key, value) {\n    return {\n        root: {\n            k: key,\n            v: value,\n            l: null,\n            r: null,\n            h: 0\n        }\n    };\n}\nexport function insert(rootNode, key, newValue) {\n    function insertNode(node, key, newValue) {\n        if (node === null) {\n            return {\n                k: key,\n                v: newValue,\n                l: null,\n                r: null,\n                h: 0\n            };\n        }\n        if (key < node.k) {\n            node.l = insertNode(node.l, key, newValue);\n        } else if (key > node.k) {\n            node.r = insertNode(node.r, key, newValue);\n        } else {\n            for (const value of newValue){\n                node.v.push(value);\n            }\n            return node;\n        }\n        node.h = 1 + Math.max(getHeight(node.l), getHeight(node.r));\n        const balanceFactor = getHeight(node.l) - getHeight(node.r);\n        if (balanceFactor > 1 && key < node.l.k) {\n            return rotateRight(node);\n        }\n        if (balanceFactor < -1 && key > node.r.k) {\n            return rotateLeft(node);\n        }\n        if (balanceFactor > 1 && key > node.l.k) {\n            node.l = rotateLeft(node.l);\n            return rotateRight(node);\n        }\n        if (balanceFactor < -1 && key < node.r.k) {\n            node.r = rotateRight(node.r);\n            return rotateLeft(node);\n        }\n        return node;\n    }\n    rootNode.root = insertNode(rootNode.root, key, newValue);\n}\nfunction getHeight(node) {\n    return node !== null ? node.h : -1;\n}\nexport function find(root, key) {\n    const node = getNodeByKey(root.root, key);\n    if (node === null) {\n        return null;\n    }\n    return node.v;\n}\nexport function remove(rootNode, key) {\n    if (rootNode === null || rootNode.root === null) {\n        return;\n    }\n    let node = rootNode.root;\n    let parentNode = null;\n    while(node != null && node.k !== key){\n        parentNode = node;\n        if (key < node.k) {\n            node = node.l;\n        } else {\n            node = node.r;\n        }\n    }\n    if (node === null) {\n        return;\n    }\n    const deleteNode = ()=>{\n        if (node.l === null && node.r === null) {\n            if (parentNode === null) {\n                rootNode.root = null;\n            } else {\n                if (parentNode.l === node) {\n                    parentNode.l = null;\n                } else {\n                    parentNode.r = null;\n                }\n            }\n        } else if (node.l != null && node.r != null) {\n            let minValueNode = node.r;\n            let minValueParent = node;\n            while(minValueNode.l != null){\n                minValueParent = minValueNode;\n                minValueNode = minValueNode.l;\n            }\n            node.k = minValueNode.k;\n            if (minValueParent === node) {\n                minValueParent.r = minValueNode.r;\n            } else {\n                minValueParent.l = minValueNode.r;\n            }\n        } else {\n            const childNode = node.l != null ? node.l : node.r;\n            if (parentNode === null) {\n                rootNode.root = childNode;\n            } else {\n                if (parentNode.l === node) {\n                    parentNode.l = childNode;\n                } else {\n                    parentNode.r = childNode;\n                }\n            }\n        }\n    };\n    deleteNode();\n}\nexport function removeDocument(root, id, key) {\n    const node = getNodeByKey(root.root, key);\n    if (!node) {\n        return;\n    }\n    if (node.v.length === 1) {\n        remove(root, key);\n        return;\n    }\n    node.v.splice(node.v.indexOf(id), 1);\n}\n\n//# sourceMappingURL=avl.js.map","import { intersect, safeArrayPush } from '../utils.js';\nexport function create() {\n    return {\n        numberToDocumentId: new Map()\n    };\n}\nexport function insert(root, key, value) {\n    if (root.numberToDocumentId.has(key)) {\n        root.numberToDocumentId.get(key).push(value);\n        return root;\n    }\n    root.numberToDocumentId.set(key, [\n        value\n    ]);\n    return root;\n}\nexport function find(root, key) {\n    return root.numberToDocumentId.get(key) ?? null;\n}\nexport function remove(root, key) {\n    if (root != null) {\n        root.numberToDocumentId.delete(key);\n    }\n    return root;\n}\nexport function removeDocument(root, id, key) {\n    var _root_numberToDocumentId_get, _root_numberToDocumentId_get1;\n    root === null || root === void 0 ? void 0 : root.numberToDocumentId.set(key, ((_root_numberToDocumentId_get = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get === void 0 ? void 0 : _root_numberToDocumentId_get.filter((v)=>v !== id)) ?? []);\n    if (((_root_numberToDocumentId_get1 = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get1 === void 0 ? void 0 : _root_numberToDocumentId_get1.length) === 0) {\n        root === null || root === void 0 ? void 0 : root.numberToDocumentId.delete(key);\n    }\n}\nexport function contains(node, key) {\n    return !(find(node, key) == null);\n}\nexport function getSize(root) {\n    let size = 0;\n    for (const [, value] of (root === null || root === void 0 ? void 0 : root.numberToDocumentId) ?? []){\n        size += value.length;\n    }\n    return size;\n}\nexport function filter(root, operation) {\n    const operationKeys = Object.keys(operation);\n    if (operationKeys.length !== 1) {\n        throw new Error('Invalid operation');\n    }\n    const operationType = operationKeys[0];\n    switch(operationType){\n        case 'eq':\n            {\n                const value = operation[operationType];\n                return root.numberToDocumentId.get(value) ?? [];\n            }\n        case 'in':\n            {\n                const value = operation[operationType];\n                const result = [];\n                for (const v of value){\n                    const ids = root.numberToDocumentId.get(v);\n                    if (ids != null) {\n                        safeArrayPush(result, ids);\n                    }\n                }\n                return result;\n            }\n        case 'nin':\n            {\n                const value = operation[operationType];\n                const result = [];\n                const keys = root.numberToDocumentId.keys();\n                for (const key of keys){\n                    if (value.includes(key)) {\n                        continue;\n                    }\n                    const ids = root.numberToDocumentId.get(key);\n                    if (ids != null) {\n                        safeArrayPush(result, ids);\n                    }\n                }\n                return result;\n            }\n    }\n    throw new Error('Invalid operation');\n}\nexport function filterArr(root, operation) {\n    const operationKeys = Object.keys(operation);\n    if (operationKeys.length !== 1) {\n        throw new Error('Invalid operation');\n    }\n    const operationType = operationKeys[0];\n    switch(operationType){\n        case 'containsAll':\n            {\n                const values = operation[operationType];\n                const ids = values.map((value)=>root.numberToDocumentId.get(value) ?? []);\n                return intersect(ids);\n            }\n    }\n    throw new Error('Invalid operation');\n}\n\n//# sourceMappingURL=flat.js.map","/**\n * Inspired by:\n * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340\n */ function _boundedLevenshtein(a, b, tolerance) {\n    // the strings are the same\n    if (a === b) {\n        return 0;\n    }\n    // a should be the shortest string\n    const swap = a;\n    if (a.length > b.length) {\n        a = b;\n        b = swap;\n    }\n    let lenA = a.length;\n    let lenB = b.length;\n    // ignore common prefix\n    let startIdx = 0;\n    while(startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)){\n        startIdx++;\n    }\n    // if string A is subfix of B, we consider the distance 0\n    // because we search for prefix!\n    // fix https://github.com/oramasearch/orama/issues/544\n    if (startIdx === lenA) {\n        return 0;\n    }\n    // ignore common suffix\n    // note: `~-` decreases by a unit in a bitwise fashion\n    while(lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)){\n        lenA--;\n        lenB--;\n    }\n    // early return when the smallest string is empty\n    if (!lenA) {\n        return lenB > tolerance ? -1 : lenB;\n    }\n    lenA -= startIdx;\n    lenB -= startIdx;\n    // If both strings are smaller than the tolerance, we accept any distance\n    // Probably the result distance is wrong, but we don't care:\n    // It is always less then the tolerance!\n    if (lenA <= tolerance && lenB <= tolerance) {\n        return lenA > lenB ? lenA : lenB;\n    }\n    const delta = lenB - lenA;\n    if (tolerance > lenB) {\n        tolerance = lenB;\n    } else if (delta > tolerance) {\n        return -1;\n    }\n    let i = 0;\n    const row = [];\n    const characterCodeCache = [];\n    while(i < tolerance){\n        characterCodeCache[i] = b.charCodeAt(startIdx + i);\n        row[i] = ++i;\n    }\n    while(i < lenB){\n        characterCodeCache[i] = b.charCodeAt(startIdx + i);\n        row[i++] = tolerance + 1;\n    }\n    const offset = tolerance - delta;\n    const haveMax = tolerance < lenB;\n    let jStart = 0;\n    let jEnd = tolerance;\n    let current = 0;\n    let left = 0;\n    let above = 0;\n    let charA = 0;\n    let j = 0;\n    // Starting the nested loops\n    for(i = 0; i < lenA; i++){\n        left = i;\n        current = i + 1;\n        charA = a.charCodeAt(startIdx + i);\n        jStart += i > offset ? 1 : 0;\n        jEnd += jEnd < lenB ? 1 : 0;\n        for(j = jStart; j < jEnd; j++){\n            above = current;\n            current = left;\n            left = row[j];\n            if (charA !== characterCodeCache[j]) {\n                // insert current\n                if (left < current) {\n                    current = left;\n                }\n                // delete current\n                if (above < current) {\n                    current = above;\n                }\n                current++;\n            }\n            row[j] = current;\n        }\n        if (haveMax && row[i + delta] > tolerance) {\n            return -1;\n        }\n    }\n    return current <= tolerance ? current : -1;\n}\n/**\n * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance\n * is greater than the given tolerance.\n * It assumes that:\n * - tolerance >= ||a| - |b|| >= 0\n */ export async function boundedLevenshtein(a, b, tolerance) {\n    const distance = _boundedLevenshtein(a, b, tolerance);\n    return {\n        distance,\n        isBounded: distance >= 0\n    };\n}\n// This is only used internally, keep in sync with the previous one\nexport function syncBoundedLevenshtein(a, b, tolerance) {\n    const distance = _boundedLevenshtein(a, b, tolerance);\n    return {\n        distance,\n        isBounded: distance >= 0\n    };\n}\nexport function levenshtein(a, b) {\n    /* c8 ignore next 3 */ if (!a.length) {\n        return b.length;\n    }\n    /* c8 ignore next 3 */ if (!b.length) {\n        return a.length;\n    }\n    const swap = a;\n    if (a.length > b.length) {\n        a = b;\n        b = swap;\n    }\n    const row = Array.from({\n        length: a.length + 1\n    }, (_, i)=>i);\n    let val = 0;\n    for(let i = 1; i <= b.length; i++){\n        let prev = i;\n        for(let j = 1; j <= a.length; j++){\n            if (b[i - 1] === a[j - 1]) {\n                val = row[j - 1];\n            } else {\n                val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));\n            }\n            row[j - 1] = prev;\n            prev = val;\n        }\n        row[a.length] = prev;\n    }\n    return row[a.length];\n}\n\n//# sourceMappingURL=levenshtein.js.map","import { syncBoundedLevenshtein } from '../components/levenshtein.js';\nimport { getOwnProperty } from '../utils.js';\nexport class Node {\n    constructor(key, subWord, end){\n        this.k = key;\n        this.s = subWord;\n        this.e = end;\n    }\n    // Node children\n    c = {};\n    // Node documents\n    d = [];\n    // Node word\n    w = '';\n    toJSON() {\n        return {\n            w: this.w,\n            s: this.s,\n            c: this.c,\n            d: this.d,\n            e: this.e\n        };\n    }\n}\nfunction updateParent(node, parent) {\n    node.w = parent.w + node.s;\n}\nfunction addDocument(node, docID) {\n    node.d.push(docID);\n}\nfunction removeDocument(node, docID) {\n    const index = node.d.indexOf(docID);\n    /* c8 ignore next 3 */ if (index === -1) {\n        return false;\n    }\n    node.d.splice(index, 1);\n    return true;\n}\nfunction findAllWords(node, output, term, exact, tolerance) {\n    if (node.e) {\n        const { w , d: docIDs  } = node;\n        if (exact && w !== term) {\n            return {};\n        }\n        // always check in own property to prevent access to inherited properties\n        // fix https://github.com/OramaSearch/orama/issues/137\n        if (getOwnProperty(output, w) == null) {\n            if (tolerance) {\n                // computing the absolute difference of letters between the term and the word\n                const difference = Math.abs(term.length - w.length);\n                // if the tolerance is set, check whether the edit distance is within tolerance.\n                // In that case, we don't need to add the word to the output\n                if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n                    output[w] = [];\n                }\n            } else {\n                // prevent default tolerance not set\n                output[w] = [];\n            }\n        }\n        // check if _output[w] exists and then add the doc to it\n        // always check in own property to prevent access to inherited properties\n        // fix https://github.com/OramaSearch/orama/issues/137\n        if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n            const docs = new Set(output[w]);\n            const docIDsLength = docIDs.length;\n            for(let i = 0; i < docIDsLength; i++){\n                docs.add(docIDs[i]);\n            }\n            output[w] = Array.from(docs);\n        }\n    }\n    // recursively search the children\n    for (const character of Object.keys(node.c)){\n        findAllWords(node.c[character], output, term, exact, tolerance);\n    }\n    return output;\n}\nfunction getCommonPrefix(a, b) {\n    let commonPrefix = '';\n    const len = Math.min(a.length, b.length);\n    for(let i = 0; i < len; i++){\n        if (a[i] !== b[i]) {\n            return commonPrefix;\n        }\n        commonPrefix += a[i];\n    }\n    return commonPrefix;\n}\nexport function create(end = false, subWord = '', key = '') {\n    return new Node(key, subWord, end);\n}\nexport function insert(root, word, docId) {\n    const wordLength = word.length;\n    for(let i = 0; i < wordLength; i++){\n        const currentCharacter = word[i];\n        const wordAtIndex = word.substring(i);\n        const rootChildCurrentChar = root.c[currentCharacter];\n        if (rootChildCurrentChar) {\n            const edgeLabel = rootChildCurrentChar.s;\n            const edgeLabelLength = edgeLabel.length;\n            const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);\n            const commonPrefixLength = commonPrefix.length;\n            // the wordAtIndex matches exactly with an existing child node\n            if (edgeLabel === wordAtIndex) {\n                addDocument(rootChildCurrentChar, docId);\n                rootChildCurrentChar.e = true;\n                return;\n            }\n            const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];\n            // the wordAtIndex is completely contained in the child node subword\n            if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n                const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n                ;\n                newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n                const newNodeChild = newNode.c[edgeLabelAtCommonPrefix];\n                newNodeChild.s = edgeLabel.substring(commonPrefixLength);\n                newNodeChild.k = edgeLabelAtCommonPrefix;\n                root.c[currentCharacter] = newNode;\n                updateParent(newNode, root);\n                updateParent(newNodeChild, newNode);\n                addDocument(newNode, docId);\n                return;\n            }\n            // the wordAtIndex is partially contained in the child node subword\n            if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n                const inbetweenNode = create(false, commonPrefix, currentCharacter);\n                inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n                root.c[currentCharacter] = inbetweenNode;\n                const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix];\n                inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength);\n                inbetweenNodeChild.k = edgeLabelAtCommonPrefix;\n                const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];\n                const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);\n                addDocument(newNode, docId);\n                inbetweenNode.c[wordAtCommonPrefix] = newNode;\n                updateParent(inbetweenNode, root);\n                updateParent(newNode, inbetweenNode);\n                updateParent(inbetweenNodeChild, inbetweenNode);\n                return;\n            }\n            // skip to the next divergent character\n            i += edgeLabelLength - 1;\n            // navigate in the child node\n            root = rootChildCurrentChar;\n        } else {\n            // if the node for the current character doesn't exist create new node\n            const newNode = create(true, wordAtIndex, currentCharacter);\n            addDocument(newNode, docId);\n            root.c[currentCharacter] = newNode;\n            updateParent(newNode, root);\n            return;\n        }\n    }\n}\nfunction _findLevenshtein(node, term, index, tolerance, originalTolerance, output) {\n    if (tolerance < 0) {\n        return;\n    }\n    if (node.w.startsWith(term)) {\n        findAllWords(node, output, term, false, 0);\n        return;\n    }\n    if (node.e) {\n        const { w , d: docIDs  } = node;\n        if (w) {\n            if (syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n                output[w] = [];\n            }\n            if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n                const docs = new Set(output[w]);\n                const docIDsLength = docIDs.length;\n                for(let i = 0; i < docIDsLength; i++){\n                    docs.add(docIDs[i]);\n                }\n                output[w] = Array.from(docs);\n            }\n        }\n    }\n    if (index >= term.length) {\n        return;\n    }\n    // Match current character without consuming tolerance\n    if (term[index] in node.c) {\n        _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output);\n    }\n    // If tolerance is still available, consider other branches:\n    // 1. Deletion (skip the current term character)\n    _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output);\n    // 2. Insertion (skip the current tree node character)\n    for(const character in node.c){\n        _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output);\n    }\n    // 3. Substitution (skip both current term character and tree node character)\n    for(const character in node.c){\n        if (character !== term[index]) {\n            _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output);\n        }\n    }\n}\nexport function find(root, { term , exact , tolerance  }) {\n    // Find the closest node to the term\n    // Use `if` condition because tolerance `0` is supposed to match only prefix.\n    // (allows infinite insertions at end, which is against normal levenshtein logic).\n    // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n    if (tolerance && !exact) {\n        const output = {};\n        tolerance = tolerance || 0;\n        _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output);\n        return output;\n    } else {\n        const termLength = term.length;\n        for(let i = 0; i < termLength; i++){\n            const character = term[i];\n            if (character in root.c) {\n                const rootChildCurrentChar = root.c[character];\n                const edgeLabel = rootChildCurrentChar.s;\n                const termSubstring = term.substring(i);\n                // find the common prefix between two words ex: prime and primate = prim\n                const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n                const commonPrefixLength = commonPrefix.length;\n                // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n                // if the common prefix is equal to the term means it is contained in the node\n                if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n                    // if tolerance is set we take the current node as the closest\n                    if (tolerance) break;\n                    return {};\n                }\n                // skip the subword length and check the next divergent character\n                i += rootChildCurrentChar.s.length - 1;\n                // navigate into the child node\n                root = rootChildCurrentChar;\n            } else {\n                return {};\n            }\n        }\n        const output = {};\n        // found the closest node we recursively search through children\n        findAllWords(root, output, term, exact, tolerance);\n        return output;\n    }\n}\nexport function contains(root, term) {\n    const termLength = term.length;\n    for(let i = 0; i < termLength; i++){\n        const character = term[i];\n        if (character in root.c) {\n            const rootChildrenChar = root.c[character];\n            const edgeLabel = rootChildrenChar.s;\n            const termSubstring = term.substring(i);\n            const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n            const commonPrefixLength = commonPrefix.length;\n            if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n                return false;\n            }\n            i += rootChildrenChar.s.length - 1;\n            root = rootChildrenChar;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\nexport function removeWord(root, term) {\n    if (!term) {\n        return false;\n    }\n    const termLength = term.length;\n    for(let i = 0; i < termLength; i++){\n        const character = term[i];\n        const parent = root;\n        if (character in root.c) {\n            i += root.c[character].s.length - 1;\n            root = root.c[character];\n            if (Object.keys(root.c).length === 0) {\n                delete parent.c[root.k];\n                return true;\n            }\n        } else {\n            return false;\n        }\n    }\n    return false;\n}\nexport function removeDocumentByWord(root, term, docID, exact = true) {\n    if (!term) {\n        return true;\n    }\n    const termLength = term.length;\n    for(let i = 0; i < termLength; i++){\n        const character = term[i];\n        if (character in root.c) {\n            const rootChildCurrentChar = root.c[character];\n            i += rootChildCurrentChar.s.length - 1;\n            root = rootChildCurrentChar;\n            if (exact && root.w !== term) {\n            // Do nothing if the exact condition is not met.\n            } else {\n                removeDocument(root, docID);\n            }\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=radix.js.map","const K = 2 // 2D points\n;\nconst EARTH_RADIUS = 6371e3 // Earth radius in meters\n;\nexport function create() {\n    return {\n        root: null\n    };\n}\nexport function insert(tree, point, docIDs) {\n    const newNode = {\n        point,\n        docIDs\n    };\n    if (tree.root == null) {\n        tree.root = newNode;\n        return;\n    }\n    let node = tree.root;\n    let depth = 0;\n    while(node !== null){\n        // Check if the current node's point matches the new point\n        if (node.point.lon === point.lon && node.point.lat === point.lat) {\n            // Merge the new docIDs with the existing ones and remove duplicates\n            const newDocIDs = node.docIDs ?? [];\n            node.docIDs = Array.from(new Set([\n                ...newDocIDs,\n                ...docIDs || []\n            ]));\n            return;\n        }\n        const axis = depth % K;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                if (node.left == null) {\n                    node.left = newNode;\n                    return;\n                }\n                node = node.left;\n            } else {\n                if (node.right == null) {\n                    node.right = newNode;\n                    return;\n                }\n                node = node.right;\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                if (node.left == null) {\n                    node.left = newNode;\n                    return;\n                }\n                node = node.left;\n            } else {\n                if (node.right == null) {\n                    node.right = newNode;\n                    return;\n                }\n                node = node.right;\n            }\n        }\n        depth++;\n    }\n}\nexport function contains(tree, point) {\n    let node = tree.root;\n    let depth = 0;\n    while(node != null){\n        if ((node === null || node === void 0 ? void 0 : node.point.lon) === point.lon && node.point.lat === point.lat) {\n            return true;\n        }\n        const axis = depth % K;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n            }\n        }\n        depth++;\n    }\n    return false;\n}\n// @todo: this is very inefficient. Fix this later.\nexport function removeDocByID(tree, point, docID) {\n    let node = tree.root;\n    let depth = 0;\n    let parentNode = null;\n    let direction = null;\n    while(node !== null){\n        if ((node === null || node === void 0 ? void 0 : node.point.lon) === point.lon && node.point.lat === point.lat) {\n            var _node_docIDs;\n            const index = (_node_docIDs = node.docIDs) === null || _node_docIDs === void 0 ? void 0 : _node_docIDs.indexOf(docID);\n            if (index !== undefined && index > -1) {\n                var // Remove the docID from the array\n                _node_docIDs1;\n                (_node_docIDs1 = node.docIDs) === null || _node_docIDs1 === void 0 ? void 0 : _node_docIDs1.splice(index, 1);\n                if (node.docIDs == null || node.docIDs.length === 0) {\n                    // If the node doesn't have any more docIDs, remove the node\n                    if (parentNode != null) {\n                        if (direction === 'left') {\n                            parentNode.left = node.left !== null ? node.left : node.right;\n                        } else if (direction === 'right') {\n                            parentNode.right = node.right !== null ? node.right : node.left;\n                        }\n                    } else {\n                        // If the node to be removed is the root\n                        tree.root = node.left !== null ? node.left : node.right;\n                    }\n                }\n                return;\n            }\n        }\n        const axis = depth % K;\n        parentNode = node;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n                direction = 'left';\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n                direction = 'right';\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                node = node === null || node === void 0 ? void 0 : node.left;\n                direction = 'left';\n            } else {\n                node = node === null || node === void 0 ? void 0 : node.right;\n                direction = 'right';\n            }\n        }\n        depth++;\n    }\n}\nexport function getDocIDsByCoordinates(tree, point) {\n    let node = tree.root;\n    let depth = 0;\n    while(node !== null){\n        if (node.point.lon === point.lon && node.point.lat === point.lat) {\n            // prettier-ignore\n            return node.docIDs ?? null;\n        }\n        const axis = depth % K;\n        // Compare by longitude\n        if (axis === 0) {\n            if (point.lon < node.point.lon) {\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        // Compare by latitude\n        } else {\n            if (point.lat < node.point.lat) {\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        depth++;\n    }\n    return null;\n}\nexport function searchByRadius(node, center, radius, inclusive = true, sort = 'asc', highPrecision = false) {\n    const distanceFn = highPrecision ? vincentyDistance : haversineDistance;\n    const stack = [\n        {\n            node,\n            depth: 0\n        }\n    ];\n    const result = [];\n    while(stack.length > 0){\n        const { node , depth  } = stack.pop();\n        if (node === null) continue;\n        const dist = distanceFn(center, node.point);\n        if (inclusive ? dist <= radius : dist > radius) {\n            result.push({\n                point: node.point,\n                docIDs: node.docIDs ?? []\n            });\n        }\n        if (node.left != null) {\n            stack.push({\n                node: node.left,\n                depth: depth + 1\n            });\n        }\n        if (node.right != null) {\n            stack.push({\n                node: node.right,\n                depth: depth + 1\n            });\n        }\n    }\n    if (sort) {\n        result.sort((a, b)=>{\n            const distA = distanceFn(center, a.point);\n            const distB = distanceFn(center, b.point);\n            return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;\n        });\n    }\n    return result;\n}\nexport function searchByPolygon(root, polygon, inclusive = true, sort = null, highPrecision = false) {\n    const stack = [\n        {\n            node: root,\n            depth: 0\n        }\n    ];\n    const result = [];\n    while(stack.length > 0){\n        const task = stack.pop();\n        if (task == null || task.node == null) continue;\n        const { node , depth  } = task;\n        const nextDepth = depth + 1;\n        if (node.left != null) {\n            stack.push({\n                node: node.left,\n                depth: nextDepth\n            });\n        }\n        if (node.right != null) {\n            stack.push({\n                node: node.right,\n                depth: nextDepth\n            });\n        }\n        const isInsidePolygon = isPointInPolygon(polygon, node.point);\n        if (isInsidePolygon && inclusive) {\n            result.push({\n                point: node.point,\n                docIDs: node.docIDs ?? []\n            });\n        } else if (!isInsidePolygon && !inclusive) {\n            result.push({\n                point: node.point,\n                docIDs: node.docIDs ?? []\n            });\n        }\n    }\n    const centroid = calculatePolygonCentroid(polygon);\n    if (sort) {\n        const sortFn = highPrecision ? vincentyDistance : haversineDistance;\n        result.sort((a, b)=>{\n            const distA = sortFn(centroid, a.point);\n            const distB = sortFn(centroid, b.point);\n            return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;\n        });\n    }\n    return result;\n}\nfunction calculatePolygonCentroid(polygon) {\n    let totalArea = 0;\n    let centroidX = 0;\n    let centroidY = 0;\n    const polygonLength = polygon.length;\n    for(let i = 0, j = polygonLength - 1; i < polygonLength; j = i++){\n        const xi = polygon[i].lon;\n        const yi = polygon[i].lat;\n        const xj = polygon[j].lon;\n        const yj = polygon[j].lat;\n        const areaSegment = xi * yj - xj * yi;\n        totalArea += areaSegment;\n        centroidX += (xi + xj) * areaSegment;\n        centroidY += (yi + yj) * areaSegment;\n    }\n    totalArea /= 2;\n    const centroidCoordinate = 6 * totalArea;\n    centroidX /= centroidCoordinate;\n    centroidY /= centroidCoordinate;\n    return {\n        lon: centroidX,\n        lat: centroidY\n    };\n}\nfunction isPointInPolygon(polygon, point) {\n    let isInside = false;\n    const x = point.lon;\n    const y = point.lat;\n    const polygonLength = polygon.length;\n    for(let i = 0, j = polygonLength - 1; i < polygonLength; j = i++){\n        const xi = polygon[i].lon;\n        const yi = polygon[i].lat;\n        const xj = polygon[j].lon;\n        const yj = polygon[j].lat;\n        const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\nfunction haversineDistance(coord1, coord2) {\n    const P = Math.PI / 180;\n    const lat1 = coord1.lat * P;\n    const lat2 = coord2.lat * P;\n    const deltaLat = (coord2.lat - coord1.lat) * P;\n    const deltaLon = (coord2.lon - coord1.lon) * P;\n    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return EARTH_RADIUS * c;\n}\nfunction vincentyDistance(coord1, coord2) {\n    // Constants for WGS 84 ellipsoidal Earth model (https://epsg.org/ellipsoid_7030/WGS-84.html)\n    // Semi-major axis of the Earth in meters\n    const a = 6378137;\n    // Flattening of the ellipsoid\n    const f = 1 / 298.257223563;\n    // Semi-minor axis\n    const b = (1 - f) * a;\n    // Convert degrees to radians for calculations\n    const P = Math.PI / 180;\n    const lat1 = coord1.lat * P;\n    const lat2 = coord2.lat * P;\n    const deltaLon = (coord2.lon - coord1.lon) * P;\n    // Reduced latitudes - account for flattening by transforming from geodetic to auxiliary latitude\n    const U1 = Math.atan((1 - f) * Math.tan(lat1));\n    const U2 = Math.atan((1 - f) * Math.tan(lat2));\n    const sinU1 = Math.sin(U1);\n    const cosU1 = Math.cos(U1);\n    const sinU2 = Math.sin(U2);\n    const cosU2 = Math.cos(U2);\n    // Initial approximation for the longitude difference between the two points\n    let lambda = deltaLon;\n    let prevLambda;\n    // Limit the iterations to ensure we don't get stuck in an infinite loop\n    let iterationLimit = 1000;\n    let sinAlpha;\n    let cos2Alpha;\n    let sinSigma;\n    let cosSigma;\n    let sigma;\n    // Refine the value of lambda (longitude difference)\n    do {\n        const sinLambda = Math.sin(lambda);\n        const cosLambda = Math.cos(lambda);\n        // Compute the trigonometric values required for Vincenty formulae\n        sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n        sigma = Math.atan2(sinSigma, cosSigma);\n        // Angular separation between the two points and the equator\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n        cos2Alpha = 1 - sinAlpha * sinAlpha;\n        const cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cos2Alpha;\n        // Compensation factor for the Earth's shape\n        const C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));\n        // Store previous lambda to check for convergence\n        prevLambda = lambda;\n        // Refine the estimate of lambda using the Vincenty formula\n        lambda = deltaLon + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n    }while (Math.abs(lambda - prevLambda) > 1e-12 && --iterationLimit > 0)\n    // Compute factors that depend on the shape of the Earth and angular distances\n    const u2 = cos2Alpha * (a * a - b * b) / (b * b);\n    const A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));\n    const B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));\n    // Compute the correction factor for the ellipsoidal shape of the Earth\n    const deltaSigma = B * sinSigma * (cosSigma - 2 * sinU1 * sinU2 / cos2Alpha + B / 4 * (cosSigma * (-1 + 2 * sinSigma * sinSigma) - B / 6 * sigma * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * sigma * sigma)));\n    // Final calculation of distance using Vincenty formula\n    const s = b * A * (sigma - deltaSigma);\n    return s;\n}\n\n//# sourceMappingURL=bkd.js.map","import { createError } from '../errors.js';\nexport function prioritizeTokenScores(arrays, boost, threshold = 1, keywordsCount) {\n    if (boost === 0) {\n        throw createError('INVALID_BOOST_VALUE');\n    }\n    const tokenScoresMap = new Map();\n    const tokenKeywordsCountMap = new Map();\n    const mapsLength = arrays.length;\n    for(let i = 0; i < mapsLength; i++){\n        const arr = arrays[i];\n        const entriesLength = arr.length;\n        for(let j = 0; j < entriesLength; j++){\n            const [token, score] = arr[j];\n            const boostScore = score * boost;\n            const oldScore = tokenScoresMap.get(token);\n            if (oldScore !== undefined) {\n                tokenScoresMap.set(token, oldScore * 1.5 + boostScore);\n                tokenKeywordsCountMap.set(token, tokenKeywordsCountMap.get(token) + 1);\n            } else {\n                tokenScoresMap.set(token, boostScore);\n                tokenKeywordsCountMap.set(token, 1);\n            }\n        }\n    }\n    const tokenScores = [];\n    for (const tokenScoreEntry of tokenScoresMap.entries()){\n        tokenScores.push(tokenScoreEntry);\n    }\n    const results = tokenScores.sort((a, b)=>b[1] - a[1]);\n    // If threshold is 1, it means we will return all the results with at least one search term,\n    // prioritizig the ones that contains more search terms (fuzzy match)\n    if (threshold === 1) {\n        return results;\n    }\n    // Prepare keywords count tracking for threshold handling\n    const allResults = results.length;\n    const tokenKeywordsCount = [];\n    for (const tokenKeywordsCountEntry of tokenKeywordsCountMap.entries()){\n        tokenKeywordsCount.push(tokenKeywordsCountEntry);\n    }\n    // Find the index of the last result with all keywords.\n    // Note that since score is multipled by 1.5 any time the token is encountered in results it means\n    // that tokenScores and tokenKeywordsCount should always have the same order.\n    const keywordsPerToken = tokenKeywordsCount.sort((a, b)=>b[1] - a[1]);\n    let lastTokenWithAllKeywords = undefined;\n    for(let i = 0; i < allResults; i++){\n        if (keywordsPerToken[i][1] === keywordsCount) {\n            lastTokenWithAllKeywords = i;\n        } else {\n            break;\n        }\n    }\n    // If no results had all the keywords, either bail out earlier or normalize\n    if (typeof lastTokenWithAllKeywords === 'undefined') {\n        if (threshold === 0) {\n            return [];\n        }\n        lastTokenWithAllKeywords = 0;\n    }\n    // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)\n    if (threshold === 0) {\n        return results.slice(0, lastTokenWithAllKeywords + 1);\n    }\n    // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms\n    // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms\n    // (fuzzy match with a minimum threshold)\n    const thresholdLength = lastTokenWithAllKeywords + Math.ceil(threshold * 100 * (results.length - lastTokenWithAllKeywords) / 100);\n    return results.slice(0, results.length + thresholdLength);\n}\nexport function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, BM25Params) {\n    const { k , b , d  } = BM25Params;\n    const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));\n    return idf * (d + tf * (k + 1)) / (tf + k * (1 - b + b * fieldLength / averageFieldLength));\n}\n\n//# sourceMappingURL=algorithms.js.map","export function getMagnitude(vector, vectorLength) {\n    let magnitude = 0;\n    for(let i = 0; i < vectorLength; i++){\n        magnitude += vector[i] * vector[i];\n    }\n    return Math.sqrt(magnitude);\n}\n// @todo: Write plugins for Node and Browsers to use parallel computation for this function\nexport function findSimilarVectors(targetVector, vectors, length, threshold = 0.8) {\n    const targetMagnitude = getMagnitude(targetVector, length);\n    const similarVectors = [];\n    for (const [vectorId, [magnitude, vector]] of Object.entries(vectors)){\n        let dotProduct = 0;\n        for(let i = 0; i < length; i++){\n            dotProduct += targetVector[i] * vector[i];\n        }\n        const similarity = dotProduct / (targetMagnitude * magnitude);\n        if (similarity >= threshold) {\n            similarVectors.push([\n                vectorId,\n                similarity\n            ]);\n        }\n    }\n    return similarVectors.sort((a, b)=>b[1] - a[1]);\n}\n\n//# sourceMappingURL=cosine-similarity.js.map","import { createError } from '../errors.js';\nimport { create as avlCreate, find as avlFind, greaterThan as avlGreaterThan, insert as avlInsert, lessThan as avlLessThan, rangeSearch as avlRangeSearch, removeDocument as avlRemoveDocument } from '../trees/avl.js';\nimport { create as flatCreate, filter as flatFilter, filterArr as flatFilterArr, insert as flatInsert, removeDocument as flatRemoveDocument } from '../trees/flat.js';\nimport { create as radixCreate, find as radixFind, insert as radixInsert, removeDocumentByWord as radixRemoveDocument } from '../trees/radix.js';\nimport { create as bkdCreate, insert as bkdInsert, removeDocByID as bkdRemoveDocByID, searchByRadius, searchByPolygon } from '../trees/bkd.js';\nimport { convertDistanceToMeters, intersect, safeArrayPush, getOwnProperty } from '../utils.js';\nimport { BM25 } from './algorithms.js';\nimport { getMagnitude } from './cosine-similarity.js';\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js';\nimport { getInternalDocumentId } from './internal-document-id-store.js';\nexport async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;\n    index.fieldLengths[prop][internalId] = tokens.length;\n    index.frequencies[prop][internalId] = {};\n}\nexport async function insertTokenScoreParameters(index, prop, id, tokens, token) {\n    let tokenFrequency = 0;\n    for (const t of tokens){\n        if (t === token) {\n            tokenFrequency++;\n        }\n    }\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    const tf = tokenFrequency / tokens.length;\n    index.frequencies[prop][internalId][token] = tf;\n    if (!(token in index.tokenOccurrences[prop])) {\n        index.tokenOccurrences[prop][token] = 0;\n    }\n    // increase a token counter that may not yet exist\n    index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;\n}\nexport async function removeDocumentScoreParameters(index, prop, id, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);\n    index.fieldLengths[prop][internalId] = undefined;\n    index.frequencies[prop][internalId] = undefined;\n}\nexport async function removeTokenScoreParameters(index, prop, token) {\n    index.tokenOccurrences[prop][token]--;\n}\nexport async function calculateResultScores(context, index, prop, term, ids) {\n    const documentIDs = Array.from(ids);\n    // Exact fields for TF-IDF\n    const avgFieldLength = index.avgFieldLength[prop];\n    const fieldLengths = index.fieldLengths[prop];\n    const oramaOccurrences = index.tokenOccurrences[prop];\n    const oramaFrequencies = index.frequencies[prop];\n    // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n    const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0;\n    const scoreList = [];\n    // Calculate TF-IDF value for each term, in each document, for each index.\n    const documentIDsLength = documentIDs.length;\n    for(let k = 0; k < documentIDsLength; k++){\n        var _oramaFrequencies_internalId;\n        const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k]);\n        const tf = (oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_internalId = oramaFrequencies[internalId]) === null || _oramaFrequencies_internalId === void 0 ? void 0 : _oramaFrequencies_internalId[term]) ?? 0;\n        const bm25 = BM25(tf, termOccurrences, context.docsCount, fieldLengths[internalId], avgFieldLength, context.params.relevance);\n        scoreList.push([\n            internalId,\n            bm25\n        ]);\n    }\n    return scoreList;\n}\nexport async function create(orama, sharedInternalDocumentStore, schema, index, prefix = '') {\n    if (!index) {\n        index = {\n            sharedInternalDocumentStore,\n            indexes: {},\n            vectorIndexes: {},\n            searchableProperties: [],\n            searchablePropertiesWithTypes: {},\n            frequencies: {},\n            tokenOccurrences: {},\n            avgFieldLength: {},\n            fieldLengths: {}\n        };\n    }\n    for (const [prop, type] of Object.entries(schema)){\n        const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n        if (typeof type === 'object' && !Array.isArray(type)) {\n            // Nested\n            create(orama, sharedInternalDocumentStore, type, index, path);\n            continue;\n        }\n        if (isVectorType(type)) {\n            index.searchableProperties.push(path);\n            index.searchablePropertiesWithTypes[path] = type;\n            index.vectorIndexes[path] = {\n                size: getVectorSize(type),\n                vectors: {}\n            };\n        } else {\n            const isArray = /\\[/.test(type);\n            switch(type){\n                case 'boolean':\n                case 'boolean[]':\n                    index.indexes[path] = {\n                        type: 'Bool',\n                        node: {\n                            true: [],\n                            false: []\n                        },\n                        isArray\n                    };\n                    break;\n                case 'number':\n                case 'number[]':\n                    index.indexes[path] = {\n                        type: 'AVL',\n                        node: avlCreate(0, []),\n                        isArray\n                    };\n                    break;\n                case 'string':\n                case 'string[]':\n                    index.indexes[path] = {\n                        type: 'Radix',\n                        node: radixCreate(),\n                        isArray\n                    };\n                    index.avgFieldLength[path] = 0;\n                    index.frequencies[path] = {};\n                    index.tokenOccurrences[path] = {};\n                    index.fieldLengths[path] = {};\n                    break;\n                case 'enum':\n                case 'enum[]':\n                    index.indexes[path] = {\n                        type: 'Flat',\n                        node: flatCreate(),\n                        isArray\n                    };\n                    break;\n                case 'geopoint':\n                    index.indexes[path] = {\n                        type: 'BKD',\n                        node: bkdCreate(),\n                        isArray\n                    };\n                    break;\n                default:\n                    throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n            }\n            index.searchableProperties.push(path);\n            index.searchablePropertiesWithTypes[path] = type;\n        }\n    }\n    return index;\n}\nasync function insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    const { type , node  } = index.indexes[prop];\n    switch(type){\n        case 'Bool':\n            {\n                node[value ? 'true' : 'false'].push(internalId);\n                break;\n            }\n        case 'AVL':\n            {\n                avlInsert(node, value, [\n                    internalId\n                ]);\n                break;\n            }\n        case 'Radix':\n            {\n                const tokens = await tokenizer.tokenize(value, language, prop);\n                await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);\n                for (const token of tokens){\n                    await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);\n                    radixInsert(node, token, internalId);\n                }\n                break;\n            }\n        case 'Flat':\n            {\n                flatInsert(node, value, internalId);\n                break;\n            }\n        case 'BKD':\n            {\n                bkdInsert(node, value, [\n                    internalId\n                ]);\n                break;\n            }\n    }\n}\nexport async function insert(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    if (isVectorType(schemaType)) {\n        return insertVector(index, prop, value, id);\n    }\n    if (!isArrayType(schemaType)) {\n        return insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n    }\n    const innerSchemaType = getInnerType(schemaType);\n    const elements = value;\n    const elementsLength = elements.length;\n    for(let i = 0; i < elementsLength; i++){\n        await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n    }\n}\nfunction insertVector(index, prop, value, id) {\n    if (!(value instanceof Float32Array)) {\n        value = new Float32Array(value);\n    }\n    const size = index.vectorIndexes[prop].size;\n    const magnitude = getMagnitude(value, size);\n    index.vectorIndexes[prop].vectors[id] = [\n        magnitude,\n        value\n    ];\n}\nasync function removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);\n    if (isVectorType(schemaType)) {\n        delete index.vectorIndexes[prop].vectors[id];\n        return true;\n    }\n    const { type , node  } = index.indexes[prop];\n    switch(type){\n        case 'AVL':\n            {\n                avlRemoveDocument(node, internalId, value);\n                return true;\n            }\n        case 'Bool':\n            {\n                const booleanKey = value ? 'true' : 'false';\n                const position = node[booleanKey].indexOf(internalId);\n                node[value ? 'true' : 'false'].splice(position, 1);\n                return true;\n            }\n        case 'Radix':\n            {\n                const tokens = await tokenizer.tokenize(value, language, prop);\n                await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);\n                for (const token of tokens){\n                    await implementation.removeTokenScoreParameters(index, prop, token);\n                    radixRemoveDocument(node, token, internalId);\n                }\n                return true;\n            }\n        case 'Flat':\n            {\n                flatRemoveDocument(node, internalId, value);\n                return true;\n            }\n        case 'BKD':\n            {\n                bkdRemoveDocByID(node, value, internalId);\n                return false;\n            }\n    }\n}\nexport async function remove(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {\n    if (!isArrayType(schemaType)) {\n        return removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);\n    }\n    const innerSchemaType = getInnerType(schemaType);\n    const elements = value;\n    const elementsLength = elements.length;\n    for(let i = 0; i < elementsLength; i++){\n        await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);\n    }\n    return true;\n}\nexport async function search(context, index, prop, term) {\n    if (!(prop in index.tokenOccurrences)) {\n        return [];\n    }\n    const { node , type  } = index.indexes[prop];\n    if (type !== 'Radix') {\n        throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop);\n    }\n    const { exact , tolerance  } = context.params;\n    const searchResult = radixFind(node, {\n        term,\n        exact,\n        tolerance\n    });\n    const ids = new Set();\n    for(const key in searchResult){\n        //skip keys inherited from prototype\n        const ownProperty = getOwnProperty(searchResult, key);\n        if (!ownProperty) continue;\n        for (const id of searchResult[key]){\n            ids.add(id);\n        }\n    }\n    return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));\n}\nexport async function searchByWhereClause(context, index, filters) {\n    const filterKeys = Object.keys(filters);\n    const filtersMap = filterKeys.reduce((acc, key)=>({\n            [key]: [],\n            ...acc\n        }), {});\n    for (const param of filterKeys){\n        const operation = filters[param];\n        if (typeof index.indexes[param] === 'undefined') {\n            throw createError('UNKNOWN_FILTER_PROPERTY', param);\n        }\n        const { node , type , isArray  } = index.indexes[param];\n        if (type === 'Bool') {\n            const idx = node;\n            const filteredIDs = idx[operation.toString()];\n            safeArrayPush(filtersMap[param], filteredIDs);\n            continue;\n        }\n        if (type === 'BKD') {\n            let reqOperation;\n            if ('radius' in operation) {\n                reqOperation = 'radius';\n            } else if ('polygon' in operation) {\n                reqOperation = 'polygon';\n            } else {\n                throw new Error(`Invalid operation ${operation}`);\n            }\n            if (reqOperation === 'radius') {\n                const { value , coordinates , unit ='m' , inside =true , highPrecision =false  } = operation[reqOperation];\n                const distanceInMeters = convertDistanceToMeters(value, unit);\n                const ids = searchByRadius(node.root, coordinates, distanceInMeters, inside, undefined, highPrecision);\n                // @todo: convert this into a for loop\n                safeArrayPush(filtersMap[param], ids.map(({ docIDs  })=>docIDs).flat());\n            } else {\n                const { coordinates , inside =true , highPrecision =false  } = operation[reqOperation];\n                const ids = searchByPolygon(node.root, coordinates, inside, undefined, highPrecision);\n                // @todo: convert this into a for loop\n                safeArrayPush(filtersMap[param], ids.map(({ docIDs  })=>docIDs).flat());\n            }\n            continue;\n        }\n        if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n            for (const raw of [\n                operation\n            ].flat()){\n                const term = await context.tokenizer.tokenize(raw, context.language, param);\n                for (const t of term){\n                    const filteredIDsResults = radixFind(node, {\n                        term: t,\n                        exact: true\n                    });\n                    safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat());\n                }\n            }\n            continue;\n        }\n        const operationKeys = Object.keys(operation);\n        if (operationKeys.length > 1) {\n            throw createError('INVALID_FILTER_OPERATION', operationKeys.length);\n        }\n        if (type === 'Flat') {\n            if (isArray) {\n                safeArrayPush(filtersMap[param], flatFilterArr(node, operation));\n            } else {\n                safeArrayPush(filtersMap[param], flatFilter(node, operation));\n            }\n            continue;\n        }\n        if (type === 'AVL') {\n            const operationOpt = operationKeys[0];\n            const operationValue = operation[operationOpt];\n            let filteredIDs = [];\n            switch(operationOpt){\n                case 'gt':\n                    {\n                        filteredIDs = avlGreaterThan(node, operationValue, false);\n                        break;\n                    }\n                case 'gte':\n                    {\n                        filteredIDs = avlGreaterThan(node, operationValue, true);\n                        break;\n                    }\n                case 'lt':\n                    {\n                        filteredIDs = avlLessThan(node, operationValue, false);\n                        break;\n                    }\n                case 'lte':\n                    {\n                        filteredIDs = avlLessThan(node, operationValue, true);\n                        break;\n                    }\n                case 'eq':\n                    {\n                        filteredIDs = avlFind(node, operationValue) ?? [];\n                        break;\n                    }\n                case 'between':\n                    {\n                        const [min, max] = operationValue;\n                        filteredIDs = avlRangeSearch(node, min, max);\n                        break;\n                    }\n            }\n            safeArrayPush(filtersMap[param], filteredIDs);\n        }\n    }\n    // AND operation: calculate the intersection between all the IDs in filterMap\n    const result = intersect(Object.values(filtersMap));\n    return result;\n}\nexport async function getSearchableProperties(index) {\n    return index.searchableProperties;\n}\nexport async function getSearchablePropertiesWithTypes(index) {\n    return index.searchablePropertiesWithTypes;\n}\nfunction loadRadixNode(node) {\n    const convertedNode = radixCreate(node.e, node.s, node.k);\n    convertedNode.d = node.d;\n    convertedNode.w = node.w;\n    for (const childrenKey of Object.keys(node.c)){\n        convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey]);\n    }\n    return convertedNode;\n}\nfunction loadFlatNode(node) {\n    return {\n        numberToDocumentId: new Map(node)\n    };\n}\nfunction saveFlatNode(node) {\n    return Array.from(node.numberToDocumentId.entries());\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n    const { indexes: rawIndexes , vectorIndexes: rawVectorIndexes , searchableProperties , searchablePropertiesWithTypes , frequencies , tokenOccurrences , avgFieldLength , fieldLengths  } = raw;\n    const indexes = {};\n    const vectorIndexes = {};\n    for (const prop of Object.keys(rawIndexes)){\n        const { node , type , isArray  } = rawIndexes[prop];\n        switch(type){\n            case 'Radix':\n                indexes[prop] = {\n                    type: 'Radix',\n                    node: loadRadixNode(node),\n                    isArray\n                };\n                break;\n            case 'Flat':\n                indexes[prop] = {\n                    type: 'Flat',\n                    node: loadFlatNode(node),\n                    isArray\n                };\n                break;\n            default:\n                indexes[prop] = rawIndexes[prop];\n        }\n    }\n    for (const idx of Object.keys(rawVectorIndexes)){\n        const vectors = rawVectorIndexes[idx].vectors;\n        for(const vec in vectors){\n            vectors[vec] = [\n                vectors[vec][0],\n                new Float32Array(vectors[vec][1])\n            ];\n        }\n        vectorIndexes[idx] = {\n            size: rawVectorIndexes[idx].size,\n            vectors\n        };\n    }\n    return {\n        sharedInternalDocumentStore,\n        indexes,\n        vectorIndexes,\n        searchableProperties,\n        searchablePropertiesWithTypes,\n        frequencies,\n        tokenOccurrences,\n        avgFieldLength,\n        fieldLengths\n    };\n}\nexport async function save(index) {\n    const { indexes , vectorIndexes , searchableProperties , searchablePropertiesWithTypes , frequencies , tokenOccurrences , avgFieldLength , fieldLengths  } = index;\n    const vectorIndexesAsArrays = {};\n    for (const idx of Object.keys(vectorIndexes)){\n        const vectors = vectorIndexes[idx].vectors;\n        for(const vec in vectors){\n            vectors[vec] = [\n                vectors[vec][0],\n                Array.from(vectors[vec][1])\n            ];\n        }\n        vectorIndexesAsArrays[idx] = {\n            size: vectorIndexes[idx].size,\n            vectors\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const savedIndexes = {};\n    for (const name of Object.keys(indexes)){\n        const { type , node , isArray  } = indexes[name];\n        if (type !== 'Flat') {\n            savedIndexes[name] = indexes[name];\n            continue;\n        }\n        savedIndexes[name] = {\n            type: 'Flat',\n            node: saveFlatNode(node),\n            isArray\n        };\n    }\n    return {\n        indexes: savedIndexes,\n        vectorIndexes: vectorIndexesAsArrays,\n        searchableProperties,\n        searchablePropertiesWithTypes,\n        frequencies,\n        tokenOccurrences,\n        avgFieldLength,\n        fieldLengths\n    };\n}\nexport async function createIndex() {\n    return {\n        create,\n        insert,\n        remove,\n        insertDocumentScoreParameters,\n        insertTokenScoreParameters,\n        removeDocumentScoreParameters,\n        removeTokenScoreParameters,\n        calculateResultScores,\n        search,\n        searchByWhereClause,\n        getSearchableProperties,\n        getSearchablePropertiesWithTypes,\n        load,\n        save\n    };\n}\n\n//# sourceMappingURL=index.js.map","import { createError } from '../errors.js';\nimport { isVectorType } from './defaults.js';\nimport { getInternalDocumentId } from './internal-document-id-store.js';\nimport { safeArrayPush } from '../utils.js';\nfunction innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {\n    const sorter = {\n        language: orama.tokenizer.language,\n        sharedInternalDocumentStore,\n        enabled: true,\n        isSorted: true,\n        sortableProperties: [],\n        sortablePropertiesWithTypes: {},\n        sorts: {}\n    };\n    for (const [prop, type] of Object.entries(schema)){\n        const path = `${prefix}${prefix ? '.' : ''}${prop}`;\n        if (sortableDeniedProperties.includes(path)) {\n            continue;\n        }\n        if (typeof type === 'object' && !Array.isArray(type)) {\n            // Nested\n            const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path);\n            safeArrayPush(sorter.sortableProperties, ret.sortableProperties);\n            sorter.sorts = {\n                ...sorter.sorts,\n                ...ret.sorts\n            };\n            sorter.sortablePropertiesWithTypes = {\n                ...sorter.sortablePropertiesWithTypes,\n                ...ret.sortablePropertiesWithTypes\n            };\n            continue;\n        }\n        if (!isVectorType(type)) {\n            switch(type){\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    sorter.sortableProperties.push(path);\n                    sorter.sortablePropertiesWithTypes[path] = type;\n                    sorter.sorts[path] = {\n                        docs: new Map(),\n                        orderedDocsToRemove: new Map(),\n                        orderedDocs: [],\n                        type: type\n                    };\n                    break;\n                case 'geopoint':\n                case 'enum':\n                    continue;\n                case 'enum[]':\n                case 'boolean[]':\n                case 'number[]':\n                case 'string[]':\n                    continue;\n                default:\n                    throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);\n            }\n        }\n    }\n    return sorter;\n}\nasync function create(orama, sharedInternalDocumentStore, schema, config) {\n    const isSortEnabled = (config === null || config === void 0 ? void 0 : config.enabled) !== false;\n    if (!isSortEnabled) {\n        return {\n            disabled: true\n        };\n    }\n    return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '');\n}\nasync function insert(sorter, prop, id, value) {\n    if (!sorter.enabled) {\n        return;\n    }\n    sorter.isSorted = false;\n    const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);\n    const s = sorter.sorts[prop];\n    s.docs.set(internalId, s.orderedDocs.length);\n    s.orderedDocs.push([\n        internalId,\n        value\n    ]);\n}\nfunction ensureIsSorted(sorter) {\n    if (sorter.isSorted) {\n        return;\n    }\n    if (!sorter.enabled) {\n        return;\n    }\n    const properties = Object.keys(sorter.sorts);\n    for (const prop of properties){\n        ensurePropertyIsSorted(sorter, prop);\n    }\n    sorter.isSorted = true;\n}\nfunction stringSort(language, value, d) {\n    return value[1].localeCompare(d[1], language);\n}\nfunction numberSort(value, d) {\n    return value[1] - d[1];\n}\nfunction booleanSort(value, d) {\n    return d[1] ? -1 : 1;\n}\nfunction ensurePropertyIsSorted(sorter, prop) {\n    const s = sorter.sorts[prop];\n    let predicate;\n    switch(s.type){\n        case 'string':\n            predicate = stringSort.bind(null, sorter.language);\n            break;\n        case 'number':\n            predicate = numberSort.bind(null);\n            break;\n        case 'boolean':\n            predicate = booleanSort.bind(null);\n            break;\n    }\n    s.orderedDocs.sort(predicate);\n    // Increment position for the greather documents\n    const orderedDocsLength = s.orderedDocs.length;\n    for(let i = 0; i < orderedDocsLength; i++){\n        const docId = s.orderedDocs[i][0];\n        s.docs.set(docId, i);\n    }\n}\nfunction ensureOrderedDocsAreDeleted(sorter) {\n    const properties = Object.keys(sorter.sorts);\n    for (const prop of properties){\n        ensureOrderedDocsAreDeletedByProperty(sorter, prop);\n    }\n}\nfunction ensureOrderedDocsAreDeletedByProperty(sorter, prop) {\n    const s = sorter.sorts[prop];\n    if (!s.orderedDocsToRemove.size) return;\n    s.orderedDocs = s.orderedDocs.filter((doc)=>!s.orderedDocsToRemove.has(doc[0]));\n    s.orderedDocsToRemove.clear();\n}\nasync function remove(sorter, prop, id) {\n    if (!sorter.enabled) {\n        return;\n    }\n    const s = sorter.sorts[prop];\n    const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);\n    const index = s.docs.get(internalId);\n    if (!index) return;\n    s.docs.delete(internalId);\n    s.orderedDocsToRemove.set(internalId, true);\n}\nasync function sortBy(sorter, docIds, by) {\n    if (!sorter.enabled) {\n        throw createError('SORT_DISABLED');\n    }\n    const property = by.property;\n    const isDesc = by.order === 'DESC';\n    const s = sorter.sorts[property];\n    if (!s) {\n        throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '));\n    }\n    ensureOrderedDocsAreDeletedByProperty(sorter, property);\n    ensureIsSorted(sorter);\n    docIds.sort((a, b)=>{\n        // This sort algorithm works leveraging on\n        // that s.docs is a map of docId -> position\n        // If a document is not indexed, it will be not present in the map\n        const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]));\n        const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]));\n        const isAIndexed = typeof indexOfA !== 'undefined';\n        const isBIndexed = typeof indexOfB !== 'undefined';\n        if (!isAIndexed && !isBIndexed) {\n            return 0;\n        }\n        // unindexed documents are always at the end\n        if (!isAIndexed) {\n            return 1;\n        }\n        if (!isBIndexed) {\n            return -1;\n        }\n        return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;\n    });\n    return docIds;\n}\nasync function getSortableProperties(sorter) {\n    if (!sorter.enabled) {\n        return [];\n    }\n    return sorter.sortableProperties;\n}\nasync function getSortablePropertiesWithTypes(sorter) {\n    if (!sorter.enabled) {\n        return {};\n    }\n    return sorter.sortablePropertiesWithTypes;\n}\nexport async function load(sharedInternalDocumentStore, raw) {\n    const rawDocument = raw;\n    if (!rawDocument.enabled) {\n        return {\n            enabled: false\n        };\n    }\n    const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop)=>{\n        const { docs , orderedDocs , type  } = rawDocument.sorts[prop];\n        acc[prop] = {\n            docs: new Map(Object.entries(docs).map(([k, v])=>[\n                    +k,\n                    v\n                ])),\n            orderedDocsToRemove: new Map(),\n            orderedDocs,\n            type\n        };\n        return acc;\n    }, {});\n    return {\n        sharedInternalDocumentStore,\n        language: rawDocument.language,\n        sortableProperties: rawDocument.sortableProperties,\n        sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n        sorts,\n        enabled: true,\n        isSorted: rawDocument.isSorted\n    };\n}\nexport async function save(sorter) {\n    if (!sorter.enabled) {\n        return {\n            enabled: false\n        };\n    }\n    ensureOrderedDocsAreDeleted(sorter);\n    ensureIsSorted(sorter);\n    const sorts = Object.keys(sorter.sorts).reduce((acc, prop)=>{\n        const { docs , orderedDocs , type  } = sorter.sorts[prop];\n        acc[prop] = {\n            docs: Object.fromEntries(docs.entries()),\n            orderedDocs,\n            type\n        };\n        return acc;\n    }, {});\n    return {\n        language: sorter.language,\n        sortableProperties: sorter.sortableProperties,\n        sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n        sorts,\n        enabled: sorter.enabled,\n        isSorted: sorter.isSorted\n    };\n}\nexport async function createSorter() {\n    return {\n        create,\n        insert,\n        remove,\n        save,\n        load,\n        sortBy,\n        getSortableProperties,\n        getSortablePropertiesWithTypes\n    };\n}\n\n//# sourceMappingURL=sorter.js.map","const DIACRITICS_CHARCODE_START = 192;\nconst DIACRITICS_CHARCODE_END = 383;\nconst CHARCODE_REPLACE_MAPPING = [\n    65,\n    65,\n    65,\n    65,\n    65,\n    65,\n    65,\n    67,\n    69,\n    69,\n    69,\n    69,\n    73,\n    73,\n    73,\n    73,\n    69,\n    78,\n    79,\n    79,\n    79,\n    79,\n    79,\n    null,\n    79,\n    85,\n    85,\n    85,\n    85,\n    89,\n    80,\n    115,\n    97,\n    97,\n    97,\n    97,\n    97,\n    97,\n    97,\n    99,\n    101,\n    101,\n    101,\n    101,\n    105,\n    105,\n    105,\n    105,\n    101,\n    110,\n    111,\n    111,\n    111,\n    111,\n    111,\n    null,\n    111,\n    117,\n    117,\n    117,\n    117,\n    121,\n    112,\n    121,\n    65,\n    97,\n    65,\n    97,\n    65,\n    97,\n    67,\n    99,\n    67,\n    99,\n    67,\n    99,\n    67,\n    99,\n    68,\n    100,\n    68,\n    100,\n    69,\n    101,\n    69,\n    101,\n    69,\n    101,\n    69,\n    101,\n    69,\n    101,\n    71,\n    103,\n    71,\n    103,\n    71,\n    103,\n    71,\n    103,\n    72,\n    104,\n    72,\n    104,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    73,\n    105,\n    74,\n    106,\n    75,\n    107,\n    107,\n    76,\n    108,\n    76,\n    108,\n    76,\n    108,\n    76,\n    108,\n    76,\n    108,\n    78,\n    110,\n    78,\n    110,\n    78,\n    110,\n    110,\n    78,\n    110,\n    79,\n    111,\n    79,\n    111,\n    79,\n    111,\n    79,\n    111,\n    82,\n    114,\n    82,\n    114,\n    82,\n    114,\n    83,\n    115,\n    83,\n    115,\n    83,\n    115,\n    83,\n    115,\n    84,\n    116,\n    84,\n    116,\n    84,\n    116,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    85,\n    117,\n    87,\n    119,\n    89,\n    121,\n    89,\n    90,\n    122,\n    90,\n    122,\n    90,\n    122,\n    115\n];\nfunction replaceChar(charCode) {\n    if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END) return charCode;\n    /* c8 ignore next  */ return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;\n}\nexport function replaceDiacritics(str) {\n    const stringCharCode = [];\n    for(let idx = 0; idx < str.length; idx++){\n        stringCharCode[idx] = replaceChar(str.charCodeAt(idx));\n    }\n    return String.fromCharCode(...stringCharCode);\n}\n\n//# sourceMappingURL=diacritics.js.map","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nconst step2List = {\n    ational: 'ate',\n    tional: 'tion',\n    enci: 'ence',\n    anci: 'ance',\n    izer: 'ize',\n    bli: 'ble',\n    alli: 'al',\n    entli: 'ent',\n    eli: 'e',\n    ousli: 'ous',\n    ization: 'ize',\n    ation: 'ate',\n    ator: 'ate',\n    alism: 'al',\n    iveness: 'ive',\n    fulness: 'ful',\n    ousness: 'ous',\n    aliti: 'al',\n    iviti: 'ive',\n    biliti: 'ble',\n    logi: 'log'\n};\nconst step3List = {\n    icate: 'ic',\n    ative: '',\n    alize: 'al',\n    iciti: 'ic',\n    ical: 'ic',\n    ful: '',\n    ness: ''\n};\n// Consonant\nconst c = '[^aeiou]';\n// Vowel\nconst v = '[aeiouy]';\n// Consonant sequence\nconst C = c + '[^aeiouy]*';\n// Vowel sequence\nconst V = v + '[aeiou]*';\n// [C]VC... is m>0\nconst mgr0 = '^(' + C + ')?' + V + C;\n// [C]VC[V] is m=1\nconst meq1 = '^(' + C + ')?' + V + C + '(' + V + ')?$';\n// [C]VCVC... is m>1\nconst mgr1 = '^(' + C + ')?' + V + C + V + C;\n// vowel in stem\nconst s_v = '^(' + C + ')?' + v;\nexport function stemmer(w) {\n    let stem;\n    let suffix;\n    let re;\n    let re2;\n    let re3;\n    let re4;\n    if (w.length < 3) {\n        return w;\n    }\n    const firstch = w.substring(0, 1);\n    if (firstch == 'y') {\n        w = firstch.toUpperCase() + w.substring(1);\n    }\n    re = /^(.+?)(ss|i)es$/;\n    re2 = /^(.+?)([^s])s$/;\n    if (re.test(w)) {\n        w = w.replace(re, '$1$2');\n    } else if (re2.test(w)) {\n        w = w.replace(re2, '$1$2');\n    }\n    re = /^(.+?)eed$/;\n    re2 = /^(.+?)(ed|ing)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        re = new RegExp(mgr0);\n        if (re.test(fp[1])) {\n            re = /.$/;\n            w = w.replace(re, '');\n        }\n    } else if (re2.test(w)) {\n        const fp = re2.exec(w);\n        stem = fp[1];\n        re2 = new RegExp(s_v);\n        if (re2.test(stem)) {\n            w = stem;\n            re2 = /(at|bl|iz)$/;\n            re3 = new RegExp('([^aeiouylsz])\\\\1$');\n            re4 = new RegExp('^' + C + v + '[^aeiouwxy]$');\n            if (re2.test(w)) {\n                w = w + 'e';\n            } else if (re3.test(w)) {\n                re = /.$/;\n                w = w.replace(re, '');\n            } else if (re4.test(w)) {\n                w = w + 'e';\n            }\n        }\n    }\n    re = /^(.+?)y$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        re = new RegExp(s_v);\n        if (stem && re.test(stem)) {\n            w = stem + 'i';\n        }\n    }\n    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        suffix = fp === null || fp === void 0 ? void 0 : fp[2];\n        re = new RegExp(mgr0);\n        if (stem && re.test(stem)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            w = stem + step2List[suffix];\n        }\n    }\n    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        suffix = fp === null || fp === void 0 ? void 0 : fp[2];\n        re = new RegExp(mgr0);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        if (stem && re.test(stem)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            w = stem + step3List[suffix];\n        }\n    }\n    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n    re2 = /^(.+?)(s|t)(ion)$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        re = new RegExp(mgr1);\n        if (stem && re.test(stem)) {\n            w = stem;\n        }\n    } else if (re2.test(w)) {\n        const fp = re2.exec(w);\n        stem = (fp === null || fp === void 0 ? void 0 : fp[1]) ?? '' + (fp === null || fp === void 0 ? void 0 : fp[2]) ?? '';\n        re2 = new RegExp(mgr1);\n        if (re2.test(stem)) {\n            w = stem;\n        }\n    }\n    re = /^(.+?)e$/;\n    if (re.test(w)) {\n        const fp = re.exec(w);\n        stem = fp === null || fp === void 0 ? void 0 : fp[1];\n        re = new RegExp(mgr1);\n        re2 = new RegExp(meq1);\n        re3 = new RegExp('^' + C + v + '[^aeiouwxy]$');\n        if (stem && (re.test(stem) || re2.test(stem) && !re3.test(stem))) {\n            w = stem;\n        }\n    }\n    re = /ll$/;\n    re2 = new RegExp(mgr1);\n    if (re.test(w) && re2.test(w)) {\n        re = /.$/;\n        w = w.replace(re, '');\n    }\n    if (firstch == 'y') {\n        w = firstch.toLowerCase() + w.substring(1);\n    }\n    return w;\n}\n\n//# sourceMappingURL=english-stemmer.js.map","import { createError } from '../../errors.js';\nimport { replaceDiacritics } from './diacritics.js';\nimport { SPLITTERS, SUPPORTED_LANGUAGES } from './languages.js';\nimport { stemmer as english } from './english-stemmer.js';\nfunction normalizeToken(prop, token) {\n    var _this_stopWords;\n    const key = `${this.language}:${prop}:${token}`;\n    if (this.normalizationCache.has(key)) {\n        return this.normalizationCache.get(key);\n    }\n    // Remove stopwords if enabled\n    if ((_this_stopWords = this.stopWords) === null || _this_stopWords === void 0 ? void 0 : _this_stopWords.includes(token)) {\n        this.normalizationCache.set(key, '');\n        return '';\n    }\n    // Apply stemming if enabled\n    if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {\n        token = this.stemmer(token);\n    }\n    token = replaceDiacritics(token);\n    this.normalizationCache.set(key, token);\n    return token;\n}\n/* c8 ignore next 10 */ function trim(text) {\n    while(text[text.length - 1] === ''){\n        text.pop();\n    }\n    while(text[0] === ''){\n        text.shift();\n    }\n    return text;\n}\nfunction tokenize(input, language, prop) {\n    if (language && language !== this.language) {\n        throw createError('LANGUAGE_NOT_SUPPORTED', language);\n    }\n    /* c8 ignore next 3 */ if (typeof input !== 'string') {\n        return [\n            input\n        ];\n    }\n    let tokens;\n    if (prop && this.tokenizeSkipProperties.has(prop)) {\n        tokens = [\n            this.normalizeToken.bind(this, prop ?? '')(input)\n        ];\n    } else {\n        const splitRule = SPLITTERS[this.language];\n        tokens = input.toLowerCase().split(splitRule).map(this.normalizeToken.bind(this, prop ?? '')).filter(Boolean);\n    }\n    const trimTokens = trim(tokens);\n    if (!this.allowDuplicates) {\n        return Array.from(new Set(trimTokens));\n    }\n    return trimTokens;\n}\nexport async function createTokenizer(config = {}) {\n    if (!config.language) {\n        config.language = 'english';\n    } else if (!SUPPORTED_LANGUAGES.includes(config.language)) {\n        throw createError('LANGUAGE_NOT_SUPPORTED', config.language);\n    }\n    // Handle stemming - It is disabled by default\n    let stemmer;\n    if (config.stemming || config.stemmer && !('stemming' in config)) {\n        if (config.stemmer) {\n            if (typeof config.stemmer !== 'function') {\n                throw createError('INVALID_STEMMER_FUNCTION_TYPE');\n            }\n            stemmer = config.stemmer;\n        } else {\n            if (config.language === 'english') {\n                stemmer = english;\n            } else {\n                throw createError('MISSING_STEMMER', config.language);\n            }\n        }\n    }\n    // Handle stopwords\n    let stopWords;\n    if (config.stopWords !== false) {\n        stopWords = [];\n        if (Array.isArray(config.stopWords)) {\n            stopWords = config.stopWords;\n        } else if (typeof config.stopWords === 'function') {\n            stopWords = await config.stopWords(stopWords);\n        } else if (config.stopWords) {\n            throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');\n        }\n        // Make sure stopWords is just an array of strings\n        if (!Array.isArray(stopWords)) {\n            throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');\n        }\n        for (const s of stopWords){\n            if (typeof s !== 'string') {\n                throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');\n            }\n        }\n    }\n    // Create the tokenizer\n    const tokenizer = {\n        tokenize,\n        language: config.language,\n        stemmer,\n        stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [\n            config.stemmerSkipProperties\n        ].flat() : []),\n        tokenizeSkipProperties: new Set(config.tokenizeSkipProperties ? [\n            config.tokenizeSkipProperties\n        ].flat() : []),\n        stopWords,\n        allowDuplicates: Boolean(config.allowDuplicates),\n        normalizeToken,\n        normalizationCache: new Map()\n    };\n    tokenizer.tokenize = tokenize.bind(tokenizer);\n    tokenizer.normalizeToken = normalizeToken;\n    return tokenizer;\n}\n\n//# sourceMappingURL=index.js.map","import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js';\nimport { createDocumentsStore } from '../components/documents-store.js';\nimport { AVAILABLE_PLUGIN_HOOKS, getAllPluginsByHook } from '../components/plugins.js';\nimport { FUNCTION_COMPONENTS, OBJECT_COMPONENTS } from '../components/hooks.js';\nimport { createIndex } from '../components/index.js';\nimport { createInternalDocumentIDStore } from '../components/internal-document-id-store.js';\nimport { createSorter } from '../components/sorter.js';\nimport { createTokenizer } from '../components/tokenizer/index.js';\nimport { createError } from '../errors.js';\nimport { uniqueId } from '../utils.js';\nfunction validateComponents(components) {\n    const defaultComponents = {\n        formatElapsedTime,\n        getDocumentIndexId,\n        getDocumentProperties,\n        validateSchema\n    };\n    for (const rawKey of FUNCTION_COMPONENTS){\n        const key = rawKey;\n        if (components[key]) {\n            if (typeof components[key] !== 'function') {\n                throw createError('COMPONENT_MUST_BE_FUNCTION', key);\n            }\n        } else {\n            // @ts-expect-error TSC is unable to resolve this\n            components[key] = defaultComponents[key];\n        }\n    }\n    for (const rawKey of Object.keys(components)){\n        if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey)) {\n            throw createError('UNSUPPORTED_COMPONENT', rawKey);\n        }\n    }\n}\nexport async function create({ schema , sort , language , components , id , plugins  }) {\n    if (!components) {\n        components = {};\n    }\n    if (!id) {\n        id = await uniqueId();\n    }\n    let tokenizer = components.tokenizer;\n    let index = components.index;\n    let documentsStore = components.documentsStore;\n    let sorter = components.sorter;\n    if (!tokenizer) {\n        // Use the default tokenizer\n        tokenizer = await createTokenizer({\n            language: language ?? 'english'\n        });\n    } else if (!tokenizer.tokenize) {\n        // If there is no tokenizer function, we assume this is a TokenizerConfig\n        tokenizer = await createTokenizer(tokenizer);\n    } else {\n        const customTokenizer = tokenizer;\n        tokenizer = customTokenizer;\n    }\n    if (components.tokenizer && language) {\n        // Accept language only if a tokenizer is not provided\n        throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER');\n    }\n    const internalDocumentStore = createInternalDocumentIDStore();\n    index ||= await createIndex();\n    sorter ||= await createSorter();\n    documentsStore ||= await createDocumentsStore();\n    // Validate all other components\n    validateComponents(components);\n    // Assign only recognized components and hooks\n    const { getDocumentProperties , getDocumentIndexId , validateSchema , formatElapsedTime  } = components;\n    const orama = {\n        data: {},\n        caches: {},\n        schema,\n        tokenizer,\n        index,\n        sorter,\n        documentsStore,\n        internalDocumentIDStore: internalDocumentStore,\n        getDocumentProperties,\n        getDocumentIndexId,\n        validateSchema,\n        beforeInsert: [],\n        afterInsert: [],\n        beforeRemove: [],\n        afterRemove: [],\n        beforeUpdate: [],\n        afterUpdate: [],\n        beforeSearch: [],\n        afterSearch: [],\n        beforeInsertMultiple: [],\n        afterInsertMultiple: [],\n        beforeRemoveMultiple: [],\n        afterRemoveMultiple: [],\n        afterUpdateMultiple: [],\n        beforeUpdateMultiple: [],\n        formatElapsedTime,\n        id,\n        plugins\n    };\n    orama.data = {\n        index: await orama.index.create(orama, internalDocumentStore, schema),\n        docs: await orama.documentsStore.create(orama, internalDocumentStore),\n        sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort)\n    };\n    for (const hook of AVAILABLE_PLUGIN_HOOKS){\n        orama[hook] = (orama[hook] ?? []).concat(await getAllPluginsByHook(orama, hook));\n    }\n    return orama;\n}\n\n//# sourceMappingURL=create.js.map","export const MODE_FULLTEXT_SEARCH = 'fulltext';\nexport const MODE_HYBRID_SEARCH = 'hybrid';\nexport const MODE_VECTOR_SEARCH = 'vector';\n\n//# sourceMappingURL=constants.js.map","export function intersectFilteredIDs(filtered, lookedUp) {\n    const map = new Map();\n    const result = [];\n    for (const id of filtered){\n        map.set(id, true);\n    }\n    for (const [id, score] of lookedUp){\n        if (map.has(id)) {\n            result.push([\n                id,\n                score\n            ]);\n            map.delete(id);\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=filters.js.map","import { createError } from '../errors.js';\nimport { getNested } from '../utils.js';\nfunction sortingPredicate(order = 'desc', a, b) {\n    if (order.toLowerCase() === 'asc') {\n        return a[1] - b[1];\n    } else {\n        return b[1] - a[1];\n    }\n}\nexport async function getFacets(orama, results, facetsConfig) {\n    const facets = {};\n    const allIDs = results.map(([id])=>id);\n    const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n    const facetKeys = Object.keys(facetsConfig);\n    const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n    for (const facet of facetKeys){\n        let values = {};\n        // Hack to guarantee the same order of ranges as specified by the user\n        // TODO: Revisit this once components land\n        if (properties[facet] === 'number') {\n            const { ranges  } = facetsConfig[facet];\n            const tmp = [];\n            for (const range of ranges){\n                tmp.push([\n                    `${range.from}-${range.to}`,\n                    0\n                ]);\n            }\n            values = Object.fromEntries(tmp);\n        }\n        facets[facet] = {\n            count: 0,\n            values\n        };\n    }\n    const allDocsLength = allDocs.length;\n    for(let i = 0; i < allDocsLength; i++){\n        const doc = allDocs[i];\n        for (const facet of facetKeys){\n            const facetValue = facet.includes('.') ? await getNested(doc, facet) : doc[facet];\n            const propertyType = properties[facet];\n            switch(propertyType){\n                case 'number':\n                    {\n                        const ranges = facetsConfig[facet].ranges;\n                        calculateNumberFacet(ranges, facets[facet].values, facetValue);\n                        break;\n                    }\n                case 'number[]':\n                    {\n                        const alreadyInsertedValues = new Set();\n                        const ranges = facetsConfig[facet].ranges;\n                        for (const v of facetValue){\n                            calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues);\n                        }\n                        break;\n                    }\n                case 'boolean':\n                case 'enum':\n                case 'string':\n                    {\n                        calculateBooleanStringOrEnumFacet(facets[facet].values, facetValue, propertyType);\n                        break;\n                    }\n                case 'boolean[]':\n                case 'enum[]':\n                case 'string[]':\n                    {\n                        const alreadyInsertedValues = new Set();\n                        const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string';\n                        for (const v of facetValue){\n                            calculateBooleanStringOrEnumFacet(facets[facet].values, v, innerType, alreadyInsertedValues);\n                        }\n                        break;\n                    }\n                default:\n                    throw createError('FACET_NOT_SUPPORTED', propertyType);\n            }\n        }\n    }\n    for (const facet of facetKeys){\n        // Count the number of values for each facet\n        facets[facet].count = Object.keys(facets[facet].values).length;\n        // Sort only string-based facets\n        if (properties[facet] === 'string') {\n            const stringFacetDefinition = facetsConfig;\n            facets[facet].values = Object.fromEntries(Object.entries(facets[facet].values).sort((a, b)=>sortingPredicate(stringFacetDefinition.sort, a, b)).slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10));\n        }\n    }\n    return facets;\n}\nfunction calculateNumberFacet(ranges, values, facetValue, alreadyInsertedValues) {\n    for (const range of ranges){\n        const value = `${range.from}-${range.to}`;\n        if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n            continue;\n        }\n        if (facetValue >= range.from && facetValue <= range.to) {\n            if (values[value] === undefined) {\n                values[value] = 1;\n            } else {\n                values[value]++;\n                if (alreadyInsertedValues) {\n                    alreadyInsertedValues.add(value);\n                }\n            }\n        }\n    }\n}\nfunction calculateBooleanStringOrEnumFacet(values, facetValue, propertyType, alreadyInsertedValues) {\n    // String or boolean based facets\n    const value = (facetValue === null || facetValue === void 0 ? void 0 : facetValue.toString()) ?? (propertyType === 'boolean' ? 'false' : '');\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n        return;\n    }\n    values[value] = (values[value] ?? 0) + 1;\n    if (alreadyInsertedValues) {\n        alreadyInsertedValues.add(value);\n    }\n}\n\n//# sourceMappingURL=facets.js.map","import { createError } from '../errors.js';\nimport { getNested, intersect, safeArrayPush } from '../utils.js';\nimport { getDocumentIdFromInternalId } from './internal-document-id-store.js';\nconst DEFAULT_REDUCE = {\n    reducer: (_, acc, res, index)=>{\n        acc[index] = res;\n        return acc;\n    },\n    getInitialValue: (length)=>Array.from({\n            length\n        })\n};\nconst ALLOWED_TYPES = [\n    'string',\n    'number',\n    'boolean'\n];\nexport async function getGroups(orama, results, groupBy) {\n    const properties = groupBy.properties;\n    const propertiesLength = properties.length;\n    const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);\n    for(let i = 0; i < propertiesLength; i++){\n        const property = properties[i];\n        if (typeof schemaProperties[property] === 'undefined') {\n            throw createError('UNKNOWN_GROUP_BY_PROPERTY', property);\n        }\n        if (!ALLOWED_TYPES.includes(schemaProperties[property])) {\n            throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property]);\n        }\n    }\n    const allIDs = results.map(([id])=>getDocumentIdFromInternalId(orama.internalDocumentIDStore, id));\n    // allDocs is already sorted by the sortBy algorithm\n    // We leverage on that to limit the number of documents returned\n    const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);\n    const allDocsLength = allDocs.length;\n    const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER;\n    const listOfValues = [];\n    // We want to understand which documents have which values\n    // and group them by the property and values\n    const g = {};\n    for(let i = 0; i < propertiesLength; i++){\n        const groupByKey = properties[i];\n        const group = {\n            property: groupByKey,\n            perValue: {}\n        };\n        const values = new Set();\n        for(let j = 0; j < allDocsLength; j++){\n            const doc = allDocs[j];\n            const value = await getNested(doc, groupByKey);\n            // we don't want to consider undefined values\n            if (typeof value === 'undefined') {\n                continue;\n            }\n            const keyValue = typeof value !== 'boolean' ? value : '' + value;\n            if (typeof group.perValue[keyValue] === 'undefined') {\n                group.perValue[keyValue] = {\n                    indexes: [],\n                    count: 0\n                };\n            }\n            if (group.perValue[keyValue].count >= returnedCount) {\n                continue;\n            }\n            // We use the index to keep track of the original order\n            group.perValue[keyValue].indexes.push(j);\n            group.perValue[keyValue].count++;\n            values.add(value);\n        }\n        listOfValues.push(Array.from(values));\n        g[groupByKey] = group;\n    }\n    const combinations = calculateCombination(listOfValues);\n    const combinationsLength = combinations.length;\n    const groups = [];\n    for(let i = 0; i < combinationsLength; i++){\n        const combination = combinations[i];\n        const combinationLength = combination.length;\n        const group = {\n            values: [],\n            indexes: []\n        };\n        const indexes = [];\n        for(let j = 0; j < combinationLength; j++){\n            const value = combination[j];\n            const property = properties[j];\n            indexes.push(g[property].perValue[typeof value !== 'boolean' ? value : '' + value].indexes);\n            group.values.push(value);\n        }\n        // We leverage on the index to sort the results by the original order\n        group.indexes = intersect(indexes).sort((a, b)=>a - b);\n        // don't generate empty groups\n        if (group.indexes.length === 0) {\n            continue;\n        }\n        groups.push(group);\n    }\n    const groupsLength = groups.length;\n    const res = Array.from({\n        length: groupsLength\n    });\n    for(let i = 0; i < groupsLength; i++){\n        const group = groups[i];\n        const reduce = groupBy.reduce || DEFAULT_REDUCE;\n        const docs = group.indexes.map((index)=>{\n            return {\n                id: allIDs[index],\n                score: results[index][1],\n                document: allDocs[index]\n            };\n        });\n        const func = reduce.reducer.bind(null, group.values);\n        const initialValue = reduce.getInitialValue(group.indexes.length);\n        const aggregationValue = docs.reduce(func, initialValue);\n        res[i] = {\n            values: group.values,\n            result: aggregationValue\n        };\n    }\n    return res;\n}\nfunction calculateCombination(arrs, index = 0) {\n    if (index + 1 === arrs.length) return arrs[index].map((item)=>[\n            item\n        ]);\n    const head = arrs[index];\n    const c = calculateCombination(arrs, index + 1);\n    const combinations = [];\n    for (const value of head){\n        for (const combination of c){\n            const result = [\n                value\n            ];\n            safeArrayPush(result, combination);\n            combinations.push(result);\n        }\n    }\n    return combinations;\n}\n\n//# sourceMappingURL=groups.js.map","import { getInternalDocumentId } from '../components/internal-document-id-store.js';\nimport { getNanosecondsTime, removeVectorsFromHits, safeArrayPush, sortTokenScorePredicate } from '../utils.js';\nimport { intersectFilteredIDs } from '../components/filters.js';\nimport { prioritizeTokenScores } from '../components/algorithms.js';\nimport { createError } from '../errors.js';\nimport { createSearchContext, defaultBM25Params, fetchDocumentsWithDistinct, fetchDocuments } from './search.js';\nimport { getFacets } from '../components/facets.js';\nimport { getGroups } from '../components/groups.js';\nimport { runBeforeSearch, runAfterSearch } from '../components/hooks.js';\nexport async function fullTextSearch(orama, params, language) {\n    const timeStart = await getNanosecondsTime();\n    if (orama.beforeSearch) {\n        await runBeforeSearch(orama.beforeSearch, orama, params, language);\n    }\n    params.relevance = Object.assign(params.relevance ?? {}, defaultBM25Params);\n    const vectorProperties = Object.keys(orama.data.index.vectorIndexes);\n    const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;\n    const { limit =10 , offset =0 , term , properties , threshold =1 , distinctOn , includeVectors =false  } = params;\n    const isPreflight = params.preflight === true;\n    const { index , docs  } = orama.data;\n    const tokens = await orama.tokenizer.tokenize(term ?? '', language);\n    // Get searchable string properties\n    let propertiesToSearch = orama.caches['propertiesToSearch'];\n    if (!propertiesToSearch) {\n        const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);\n        propertiesToSearch = await orama.index.getSearchableProperties(index);\n        propertiesToSearch = propertiesToSearch.filter((prop)=>propertiesToSearchWithTypes[prop].startsWith('string'));\n        orama.caches['propertiesToSearch'] = propertiesToSearch;\n    }\n    if (properties && properties !== '*') {\n        for (const prop of properties){\n            if (!propertiesToSearch.includes(prop)) {\n                throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '));\n            }\n        }\n        propertiesToSearch = propertiesToSearch.filter((prop)=>properties.includes(prop));\n    }\n    // Create the search context and the results\n    const context = await createSearchContext(orama.tokenizer, orama.index, orama.documentsStore, language, params, propertiesToSearch, tokens, await orama.documentsStore.count(docs), timeStart);\n    // If filters are enabled, we need to get the IDs of the documents that match the filters.\n    const hasFilters = Object.keys(params.where ?? {}).length > 0;\n    let whereFiltersIDs = [];\n    if (hasFilters) {\n        whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where);\n    }\n    const tokensLength = tokens.length;\n    if (tokensLength || properties && properties.length > 0) {\n        // Now it's time to loop over all the indices and get the documents IDs for every single term\n        const indexesLength = propertiesToSearch.length;\n        for(let i = 0; i < indexesLength; i++){\n            var _params_boost;\n            const prop = propertiesToSearch[i];\n            if (tokensLength !== 0) {\n                for(let j = 0; j < tokensLength; j++){\n                    const term = tokens[j];\n                    // Lookup\n                    const scoreList = await orama.index.search(context, index, prop, term);\n                    safeArrayPush(context.indexMap[prop][term], scoreList);\n                }\n            } else {\n                context.indexMap[prop][''] = [];\n                const scoreList = await orama.index.search(context, index, prop, '');\n                safeArrayPush(context.indexMap[prop][''], scoreList);\n            }\n            const docIds = context.indexMap[prop];\n            const vals = Object.values(docIds);\n            context.docsIntersection[prop] = prioritizeTokenScores(vals, (params === null || params === void 0 ? void 0 : (_params_boost = params.boost) === null || _params_boost === void 0 ? void 0 : _params_boost[prop]) ?? 1, threshold, tokensLength);\n            const uniqueDocs = context.docsIntersection[prop];\n            const uniqueDocsLength = uniqueDocs.length;\n            for(let i = 0; i < uniqueDocsLength; i++){\n                const [id, score] = uniqueDocs[i];\n                const prevScore = context.uniqueDocsIDs[id];\n                if (prevScore) {\n                    context.uniqueDocsIDs[id] = prevScore + score + 0.5;\n                } else {\n                    context.uniqueDocsIDs[id] = score;\n                }\n            }\n        }\n    } else if (tokens.length === 0 && term) {\n        // This case is hard to handle correctly.\n        // For the time being, if tokenizer returns empty array but the term is not empty,\n        // we returns an empty result set\n        context.uniqueDocsIDs = {};\n    } else {\n        context.uniqueDocsIDs = Object.fromEntries(Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map((k)=>[\n                k,\n                0\n            ]));\n    }\n    // Get unique doc IDs from uniqueDocsIDs map\n    let uniqueDocsArray = Object.entries(context.uniqueDocsIDs).map(([id, score])=>[\n            +id,\n            score\n        ]);\n    // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n    if (hasFilters) {\n        uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray);\n    }\n    if (params.sortBy) {\n        if (typeof params.sortBy === 'function') {\n            const ids = uniqueDocsArray.map(([id])=>id);\n            const docs = await orama.documentsStore.getMultiple(orama.data.docs, ids);\n            const docsWithIdAndScore = docs.map((d, i)=>[\n                    uniqueDocsArray[i][0],\n                    uniqueDocsArray[i][1],\n                    d\n                ]);\n            docsWithIdAndScore.sort(params.sortBy);\n            uniqueDocsArray = docsWithIdAndScore.map(([id, score])=>[\n                    id,\n                    score\n                ]);\n        } else {\n            uniqueDocsArray = await orama.sorter.sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy).then((results)=>results.map(([id, score])=>[\n                        getInternalDocumentId(orama.internalDocumentIDStore, id),\n                        score\n                    ]));\n        }\n    } else {\n        uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate);\n    }\n    let results;\n    if (!isPreflight && distinctOn) {\n        results = await fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn);\n    } else if (!isPreflight) {\n        results = await fetchDocuments(orama, uniqueDocsArray, offset, limit);\n    }\n    const searchResult = {\n        elapsed: {\n            formatted: '',\n            raw: 0\n        },\n        // We keep the hits array empty if it's a preflight request.\n        hits: [],\n        count: uniqueDocsArray.length\n    };\n    if (typeof results !== 'undefined') {\n        searchResult.hits = results.filter(Boolean);\n        // Vectors can be very large, so we remove them from the result if not needed\n        if (!includeVectors) {\n            removeVectorsFromHits(searchResult, vectorProperties);\n        }\n    }\n    if (shouldCalculateFacets) {\n        // Populate facets if needed\n        const facets = await getFacets(orama, uniqueDocsArray, params.facets);\n        searchResult.facets = facets;\n    }\n    if (params.groupBy) {\n        searchResult.groups = await getGroups(orama, uniqueDocsArray, params.groupBy);\n    }\n    if (orama.afterSearch) {\n        await runAfterSearch(orama.afterSearch, orama, params, language, searchResult);\n    }\n    // Calculate elapsed time only at the end of the function\n    searchResult.elapsed = await orama.formatElapsedTime(await getNanosecondsTime() - context.timeStart);\n    return searchResult;\n}\n\n//# sourceMappingURL=search-fulltext.js.map","import { createSearchContext } from './search.js';\nimport { getNanosecondsTime, formatNanoseconds } from '../utils.js';\nimport { getFacets } from '../components/facets.js';\nimport { createError } from '../errors.js';\nimport { findSimilarVectors } from '../components/cosine-similarity.js';\nimport { intersectFilteredIDs } from '../components/filters.js';\nimport { getGroups } from '../components/groups.js';\nimport { getInternalDocumentId, getDocumentIdFromInternalId } from '../components/internal-document-id-store.js';\nimport { runBeforeSearch, runAfterSearch } from '../components/hooks.js';\nexport async function searchVector(orama, params, language = 'english') {\n    const timeStart = await getNanosecondsTime();\n    if (orama.beforeSearch) {\n        await runBeforeSearch(orama.beforeSearch, orama, params, language);\n    }\n    const { vector  } = params;\n    if (vector && (!('value' in vector) || !('property' in vector))) {\n        throw createError('INVALID_VECTOR_INPUT', Object.keys(vector).join(', '));\n    }\n    const { limit =10 , offset =0 , includeVectors =false  } = params;\n    const vectorIndex = orama.data.index.vectorIndexes[vector.property];\n    const vectorSize = vectorIndex.size;\n    const vectors = vectorIndex.vectors;\n    const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;\n    const hasFilters = Object.keys(params.where ?? {}).length > 0;\n    const { index , docs: oramaDocs  } = orama.data;\n    if ((vector === null || vector === void 0 ? void 0 : vector.value.length) !== vectorSize) {\n        // eslint-disable-next-line\n        throw createError('INVALID_INPUT_VECTOR', vector === null || vector === void 0 ? void 0 : vector.property, vectorSize, vector === null || vector === void 0 ? void 0 : vector.value.length);\n    }\n    if (!(vector instanceof Float32Array)) {\n        vector.value = new Float32Array(vector.value);\n    }\n    let results = findSimilarVectors(vector.value, vectors, vectorSize, params.similarity).map(([id, score])=>[\n            getInternalDocumentId(orama.internalDocumentIDStore, id),\n            score\n        ]);\n    let propertiesToSearch = orama.caches['propertiesToSearch'];\n    if (!propertiesToSearch) {\n        const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);\n        propertiesToSearch = await orama.index.getSearchableProperties(index);\n        propertiesToSearch = propertiesToSearch.filter((prop)=>propertiesToSearchWithTypes[prop].startsWith('string'));\n        orama.caches['propertiesToSearch'] = propertiesToSearch;\n    }\n    const tokens = [];\n    const context = await createSearchContext(orama.tokenizer, orama.index, orama.documentsStore, language, params, propertiesToSearch, tokens, await orama.documentsStore.count(oramaDocs), timeStart);\n    let whereFiltersIDs = [];\n    if (hasFilters) {\n        whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where);\n        results = intersectFilteredIDs(whereFiltersIDs, results);\n    }\n    let facetsResults = [];\n    if (shouldCalculateFacets) {\n        // Populate facets if needed\n        const facets = await getFacets(orama, results, params.facets);\n        facetsResults = facets;\n    }\n    const docs = Array.from({\n        length: limit\n    });\n    for(let i = 0; i < limit; i++){\n        const result = results[i + offset];\n        if (!result) {\n            break;\n        }\n        const doc = orama.data.docs.docs[result[0]];\n        if (doc) {\n            if (!includeVectors) {\n                doc[vector.property] = null;\n            }\n            const newDoc = {\n                id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, result[0]),\n                score: result[1],\n                document: doc\n            };\n            docs[i] = newDoc;\n        }\n    }\n    let groups = [];\n    if (params.groupBy) {\n        groups = await getGroups(orama, results, params.groupBy);\n    }\n    if (orama.afterSearch) {\n        await runAfterSearch(orama.afterSearch, orama, params, language, results);\n    }\n    const timeEnd = await getNanosecondsTime();\n    const elapsedTime = timeEnd - timeStart;\n    return {\n        count: results.length,\n        hits: docs.filter(Boolean),\n        elapsed: {\n            raw: Number(elapsedTime),\n            formatted: await formatNanoseconds(elapsedTime)\n        },\n        ...facetsResults ? {\n            facets: facetsResults\n        } : {},\n        ...groups ? {\n            groups\n        } : {}\n    };\n}\n\n//# sourceMappingURL=search-vector.js.map","import { getNanosecondsTime, safeArrayPush, formatNanoseconds, removeVectorsFromHits } from '../utils.js';\nimport { intersectFilteredIDs } from '../components/filters.js';\nimport { prioritizeTokenScores } from '../components/algorithms.js';\nimport { createError } from '../errors.js';\nimport { createSearchContext, defaultBM25Params } from './search.js';\nimport { getFacets } from '../components/facets.js';\nimport { getGroups } from '../components/groups.js';\nimport { findSimilarVectors } from '../components/cosine-similarity.js';\nimport { getInternalDocumentId } from '../components/internal-document-id-store.js';\nimport { fetchDocuments } from './search.js';\nimport { runBeforeSearch, runAfterSearch } from '../components/hooks.js';\nexport async function hybridSearch(orama, params, language) {\n    const timeStart = await getNanosecondsTime();\n    if (orama.beforeSearch) {\n        await runBeforeSearch(orama.beforeSearch, orama, params, language);\n    }\n    const { offset =0 , limit =10 , includeVectors =false  } = params;\n    const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;\n    const [fullTextIDs, vectorIDs] = await Promise.all([\n        getFullTextSearchIDs(orama, params, language),\n        getVectorSearchIDs(orama, params)\n    ]);\n    const { index , docs  } = orama.data;\n    let uniqueTokenScores = mergeAndRankResults(fullTextIDs, vectorIDs, params.term ?? '');\n    // @todo avoid tokenize twice\n    const tokens = await orama.tokenizer.tokenize(params.term ?? '', language);\n    let propertiesToSearch = orama.caches['propertiesToSearch'];\n    if (!propertiesToSearch) {\n        const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);\n        propertiesToSearch = await orama.index.getSearchableProperties(index);\n        propertiesToSearch = propertiesToSearch.filter((prop)=>propertiesToSearchWithTypes[prop].startsWith('string'));\n        orama.caches['propertiesToSearch'] = propertiesToSearch;\n    }\n    if (params.properties && params.properties !== '*') {\n        for (const prop of params.properties){\n            if (!propertiesToSearch.includes(prop)) {\n                throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '));\n            }\n        }\n        propertiesToSearch = propertiesToSearch.filter((prop)=>params.properties.includes(prop));\n    }\n    // @todo avoid create context twice\n    const context = await createSearchContext(orama.tokenizer, orama.index, orama.documentsStore, language, params, propertiesToSearch, tokens, await orama.documentsStore.count(docs), timeStart);\n    const hasFilters = Object.keys(params.where ?? {}).length > 0;\n    let whereFiltersIDs = [];\n    if (hasFilters) {\n        whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where);\n        uniqueTokenScores = intersectFilteredIDs(whereFiltersIDs, uniqueTokenScores).slice(offset, offset + limit);\n    }\n    let facetsResults;\n    if (shouldCalculateFacets) {\n        const facets = await getFacets(orama, uniqueTokenScores, params.facets);\n        facetsResults = facets;\n    }\n    let groups;\n    if (params.groupBy) {\n        groups = await getGroups(orama, uniqueTokenScores, params.groupBy);\n    }\n    const results = (await fetchDocuments(orama, uniqueTokenScores, offset, limit)).filter(Boolean);\n    if (orama.afterSearch) {\n        await runAfterSearch(orama.afterSearch, orama, params, language, results);\n    }\n    const timeEnd = await getNanosecondsTime();\n    const returningResults = {\n        count: uniqueTokenScores.length,\n        elapsed: {\n            raw: Number(timeEnd - timeStart),\n            formatted: await formatNanoseconds(timeEnd - timeStart)\n        },\n        hits: results,\n        ...facetsResults ? {\n            facets: facetsResults\n        } : {},\n        ...groups ? {\n            groups\n        } : {}\n    };\n    if (!includeVectors) {\n        const vectorProperties = Object.keys(orama.data.index.vectorIndexes);\n        removeVectorsFromHits(returningResults, vectorProperties);\n    }\n    return returningResults;\n}\nasync function getFullTextSearchIDs(orama, params, language) {\n    const timeStart = await getNanosecondsTime();\n    params.relevance = Object.assign(params.relevance ?? {}, defaultBM25Params);\n    const { term , properties , threshold =1  } = params;\n    const { index , docs  } = orama.data;\n    const tokens = await orama.tokenizer.tokenize(term ?? '', language);\n    // Get searchable string properties\n    let propertiesToSearch = orama.caches['propertiesToSearch'];\n    if (!propertiesToSearch) {\n        const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);\n        propertiesToSearch = await orama.index.getSearchableProperties(index);\n        propertiesToSearch = propertiesToSearch.filter((prop)=>propertiesToSearchWithTypes[prop].startsWith('string'));\n        orama.caches['propertiesToSearch'] = propertiesToSearch;\n    }\n    if (properties && properties !== '*') {\n        for (const prop of properties){\n            if (!propertiesToSearch.includes(prop)) {\n                throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '));\n            }\n        }\n        propertiesToSearch = propertiesToSearch.filter((prop)=>properties.includes(prop));\n    }\n    // Create the search context and the results\n    const context = await createSearchContext(orama.tokenizer, orama.index, orama.documentsStore, language, params, propertiesToSearch, tokens, await orama.documentsStore.count(docs), timeStart);\n    const tokensLength = tokens.length;\n    if (tokensLength || properties && properties.length > 0) {\n        // Now it's time to loop over all the indices and get the documents IDs for every single term\n        const indexesLength = propertiesToSearch.length;\n        for(let i = 0; i < indexesLength; i++){\n            var _params_boost;\n            const prop = propertiesToSearch[i];\n            if (tokensLength !== 0) {\n                for(let j = 0; j < tokensLength; j++){\n                    const term = tokens[j];\n                    // Lookup\n                    const scoreList = await orama.index.search(context, index, prop, term);\n                    safeArrayPush(context.indexMap[prop][term], scoreList);\n                }\n            } else {\n                context.indexMap[prop][''] = [];\n                const scoreList = await orama.index.search(context, index, prop, '');\n                safeArrayPush(context.indexMap[prop][''], scoreList);\n            }\n            const docIds = context.indexMap[prop];\n            const vals = Object.values(docIds);\n            context.docsIntersection[prop] = prioritizeTokenScores(vals, (params === null || params === void 0 ? void 0 : (_params_boost = params.boost) === null || _params_boost === void 0 ? void 0 : _params_boost[prop]) ?? 1, threshold, tokensLength);\n            const uniqueDocs = context.docsIntersection[prop];\n            const uniqueDocsLength = uniqueDocs.length;\n            for(let i = 0; i < uniqueDocsLength; i++){\n                const [id, score] = uniqueDocs[i];\n                const prevScore = context.uniqueDocsIDs[id];\n                if (prevScore) {\n                    context.uniqueDocsIDs[id] = prevScore + score + 0.5;\n                } else {\n                    context.uniqueDocsIDs[id] = score;\n                }\n            }\n        }\n    } else if (tokens.length === 0 && term) {\n        // This case is hard to handle correctly.\n        // For the time being, if tokenizer returns empty array but the term is not empty,\n        // we returns an empty result set\n        context.uniqueDocsIDs = {};\n    } else {\n        context.uniqueDocsIDs = Object.fromEntries(Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map((k)=>[\n                k,\n                0\n            ]));\n    }\n    const uniqueIDs = Object.entries(context.uniqueDocsIDs).map(([id, score])=>[\n            +id,\n            score\n        ]).sort((a, b)=>b[1] - a[1]);\n    return minMaxScoreNormalization(uniqueIDs);\n}\nexport async function getVectorSearchIDs(orama, params) {\n    const vector = params.vector;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n    const vectorIndex = orama.data.index.vectorIndexes[vector === null || vector === void 0 ? void 0 : vector.property];\n    const vectorSize = vectorIndex.size;\n    const vectors = vectorIndex.vectors;\n    if (vector && (!vector.value || !vector.property)) {\n        throw createError('INVALID_VECTOR_INPUT', Object.keys(vector).join(', '));\n    }\n    if (vector.value.length !== vectorSize) {\n        throw createError('INVALID_INPUT_VECTOR', vector.property, vectorSize, vector.value.length);\n    }\n    if (!(vector instanceof Float32Array)) {\n        vector.value = new Float32Array(vector.value);\n    }\n    const uniqueIDs = findSimilarVectors(vector.value, vectors, vectorSize, params.similarity).map(([id, score])=>[\n            getInternalDocumentId(orama.internalDocumentIDStore, id),\n            score\n        ]);\n    return minMaxScoreNormalization(uniqueIDs);\n}\nfunction minMaxScoreNormalization(results) {\n    const maxScore = Math.max(...results.map(([, score])=>score));\n    return results.map(([id, score])=>[\n            id,\n            score / maxScore\n        ]);\n}\nfunction normalizeScore(score, maxScore) {\n    return score / maxScore;\n}\nfunction hybridScore(textScore, vectorScore, textWeight, vectorWeight) {\n    return textScore * textWeight + vectorScore * vectorWeight;\n}\nfunction mergeAndRankResults(textResults, vectorResults, query) {\n    const maxTextScore = Math.max(...textResults.map(([, score])=>score));\n    const maxVectorScore = Math.max(...vectorResults.map(([, score])=>score));\n    const { textWeight , vectorWeight  } = getQueryWeights(query);\n    const mergedResults = new Map();\n    const textResultsLength = textResults.length;\n    for(let i = 0; i < textResultsLength; i++){\n        const normalizedScore = normalizeScore(textResults[i][1], maxTextScore);\n        //                                                    ^ 1 here refers to \"score\"\n        const hybridScoreValue = hybridScore(normalizedScore, 0, textWeight, vectorWeight);\n        mergedResults.set(textResults[i][0], hybridScoreValue);\n    //                               ^ 0 here refers to \"id\"\n    }\n    const vectorResultsLength = vectorResults.length;\n    for(let i = 0; i < vectorResultsLength; i++){\n        const normalizedScore = normalizeScore(vectorResults[i][1], maxVectorScore);\n        //                                                      ^ 1 here refers to \"score\"\n        if (mergedResults.has(vectorResults[i][0])) {\n            let existingRes = mergedResults.get(vectorResults[i][0]);\n            //                                                   ^ 0 here refers to \"id\"\n            mergedResults.set(vectorResults[i][0], existingRes += hybridScore(0, normalizedScore, textWeight, vectorWeight));\n        //                                 ^ 0 here refers to \"id\"\n        } else {\n            mergedResults.set(vectorResults[i][0], hybridScore(0, normalizedScore, textWeight, vectorWeight));\n        //                                 ^ 0 here refers to \"id\"\n        }\n    }\n    return [\n        ...mergedResults\n    ].sort((a, b)=>b[1] - a[1]);\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getQueryWeights(query) {\n    // In the next versions of Orama, we will ship a plugin containing a ML model to adjust the weights\n    // based on whether the query is keyword-focused, conceptual, etc.\n    // For now, we just return a fixed value.\n    return {\n        textWeight: 0.5,\n        vectorWeight: 0.5\n    };\n}\n\n//# sourceMappingURL=search-hybrid.js.map","import { getDocumentIdFromInternalId } from '../components/internal-document-id-store.js';\nimport { createError } from '../errors.js';\nimport { getNested } from '../utils.js';\nimport { MODE_FULLTEXT_SEARCH, MODE_HYBRID_SEARCH, MODE_VECTOR_SEARCH } from '../constants.js';\nimport { fullTextSearch } from './search-fulltext.js';\nimport { searchVector } from './search-vector.js';\nimport { hybridSearch } from './search-hybrid.js';\nexport const defaultBM25Params = {\n    k: 1.2,\n    b: 0.75,\n    d: 0.5\n};\nexport async function createSearchContext(tokenizer, index, documentsStore, language, params, properties, tokens, docsCount, timeStart) {\n    // If filters are enabled, we need to get the IDs of the documents that match the filters.\n    // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n    // let whereFiltersIDs: string[] = [];\n    // if (hasFilters) {\n    //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n    // }\n    // indexMap is an object containing all the indexes considered for the current search,\n    // and an array of doc IDs for each token in all the indices.\n    //\n    // Given the search term \"quick brown fox\" on the \"description\" index,\n    // indexMap will look like this:\n    //\n    // {\n    //   description: {\n    //     quick: [doc1, doc2, doc3],\n    //     brown: [doc2, doc4],\n    //     fox:   [doc2]\n    //   }\n    // }\n    const indexMap = {};\n    // After we create the indexMap, we need to calculate the intersection\n    // between all the postings lists for each token.\n    // Given the example above, docsIntersection will look like this:\n    //\n    // {\n    //   description: [doc2]\n    // }\n    //\n    // as doc2 is the only document present in all the postings lists for the \"description\" index.\n    const docsIntersection = {};\n    for (const prop of properties){\n        const tokensMap = {};\n        for (const token of tokens){\n            tokensMap[token] = [];\n        }\n        indexMap[prop] = tokensMap;\n        docsIntersection[prop] = [];\n    }\n    return {\n        timeStart,\n        tokenizer,\n        index,\n        documentsStore,\n        language,\n        params,\n        docsCount,\n        uniqueDocsIDs: {},\n        indexMap,\n        docsIntersection\n    };\n}\nexport async function search(orama, params, language) {\n    const mode = params.mode ?? MODE_FULLTEXT_SEARCH;\n    if (mode === MODE_FULLTEXT_SEARCH) {\n        return fullTextSearch(orama, params, language);\n    }\n    if (mode === MODE_VECTOR_SEARCH) {\n        return searchVector(orama, params);\n    }\n    if (mode === MODE_HYBRID_SEARCH) {\n        return hybridSearch(orama, params);\n    }\n    throw createError('INVALID_SEARCH_MODE', mode);\n}\nexport async function fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn) {\n    const docs = orama.data.docs;\n    // Keep track which values we already seen\n    const values = new Map();\n    // We cannot know how many results we will have in the end,\n    // so we need cannot pre-allocate the array.\n    const results = [];\n    const resultIDs = new Set();\n    const uniqueDocsArrayLength = uniqueDocsArray.length;\n    let count = 0;\n    for(let i = 0; i < uniqueDocsArrayLength; i++){\n        const idAndScore = uniqueDocsArray[i];\n        // If there are no more results, just break the loop\n        if (typeof idAndScore === 'undefined') {\n            continue;\n        }\n        const [id, score] = idAndScore;\n        if (resultIDs.has(id)) {\n            continue;\n        }\n        const doc = await orama.documentsStore.get(docs, id);\n        const value = await getNested(doc, distinctOn);\n        if (typeof value === 'undefined' || values.has(value)) {\n            continue;\n        }\n        values.set(value, true);\n        count++;\n        // We shouldn't consider the document if it's not in the offset range\n        if (count <= offset) {\n            continue;\n        }\n        results.push({\n            id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id),\n            score,\n            document: doc\n        });\n        resultIDs.add(id);\n        // reached the limit, break the loop\n        if (count >= offset + limit) {\n            break;\n        }\n    }\n    return results;\n}\nexport async function fetchDocuments(orama, uniqueDocsArray, offset, limit) {\n    const docs = orama.data.docs;\n    const results = Array.from({\n        length: limit\n    });\n    const resultIDs = new Set();\n    // We already have the list of ALL the document IDs containing the search terms.\n    // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n    // to provide pagination capabilities to the search.\n    for(let i = offset; i < limit + offset; i++){\n        const idAndScore = uniqueDocsArray[i];\n        // If there are no more results, just break the loop\n        if (typeof idAndScore === 'undefined') {\n            break;\n        }\n        const [id, score] = idAndScore;\n        if (!resultIDs.has(id)) {\n            // We retrieve the full document only AFTER making sure that we really want it.\n            // We never retrieve the full document preventively.\n            const fullDoc = await orama.documentsStore.get(docs, id);\n            results[i] = {\n                id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id),\n                score,\n                document: fullDoc\n            };\n            resultIDs.add(id);\n        }\n    }\n    return results;\n}\n\n//# sourceMappingURL=search.js.map","export async function load(orama, raw) {\n    orama.internalDocumentIDStore.load(orama, raw.internalDocumentIDStore);\n    orama.data.index = await orama.index.load(orama.internalDocumentIDStore, raw.index);\n    orama.data.docs = await orama.documentsStore.load(orama.internalDocumentIDStore, raw.docs);\n    orama.data.sorting = await orama.sorter.load(orama.internalDocumentIDStore, raw.sorting);\n    orama.tokenizer.language = raw.language;\n}\nexport async function save(orama) {\n    return {\n        internalDocumentIDStore: orama.internalDocumentIDStore.save(orama.internalDocumentIDStore),\n        index: await orama.index.save(orama.data.index),\n        docs: await orama.documentsStore.save(orama.data.docs),\n        sorting: await orama.sorter.save(orama.data.sorting),\n        language: orama.tokenizer.language\n    };\n}\n\n//# sourceMappingURL=serialization.js.map","import { create, load, type Orama, type RawData, search } from '@orama/orama';\r\n\r\n\r\nconst defaultHtmlSchema = {\r\n\ttype:    'string',\r\n\tcontent: 'string',\r\n\tpath:    'string',\r\n} as const;\r\n\r\n// Creating a custom restore function because @orama/plugin-data-persistence\r\n// exposes nodejs imports that don't work in the browser.\r\nconst customRestore = async (\r\n\tdata: RawData,\r\n): Promise<Orama<any, any, any, any>> => {\r\n\tconst db = await create({\r\n\t\tschema: defaultHtmlSchema,\r\n\t});\r\n\r\n\tawait load(db, data);\r\n\r\n\treturn db;\r\n};\r\n\r\n\r\n(async () => {\r\n\tconst JSONIndex = await fetch('../searchIndexes.json')\r\n\t\t.then(d => d.json()).then(d => d);\r\n\r\n\tconst db = await customRestore(JSONIndex);\r\n\r\n\tself.onmessage = async (ev: MessageEvent) => {\r\n\t\tconst searchParams = ev.data;\r\n\t\tconst result = await search(db, searchParams);\r\n\r\n\t\tpostMessage(result);\r\n\t};\r\n})();\r\n"],"names":["STEMMERS","SPLITTERS","SUPPORTED_LANGUAGES","baseId","lastId","nano","milli","second","MAX_ARGUMENT_FOR_STACK","safeArrayPush","arr","newArr","i","sprintf","template","args","replaceArgs","groups","rawWidth","type","position","replacement","width","value","padding","precision","w","isInsideWebWorker","isInsideNode","getNanosecondTimeViaPerformance","formatNanoseconds","getNanosecondsTime","uniqueId","getOwnProperty","object","property","sortTokenScorePredicate","a","b","intersect","arrays","tmp","set","elem","found","count","e","getDocumentProperties","doc","paths","properties","pathsLength","path","pathTokens","current","pathTokensLength","j","getNested","obj","mapDistanceToMeters","convertDistanceToMeters","distance","unit","ratio","createError","removeVectorsFromHits","searchResult","vectorProperties","result","acc","prop","lastKey","key","allLanguages","errors","code","error","formatElapsedTime","n","getDocumentIndexId","validateSchema","schema","valueLength","isVectorType","vectorSize","getVectorSize","isArrayType","expectedType","getInnerType","subProp","IS_ARRAY_TYPE","INNER_TYPE","size","createInternalDocumentIDStore","save","load","store","orama","raw","internalIdToId","getInternalDocumentId","id","internalId","currentId","getDocumentIdFromInternalId","create","_","sharedInternalDocumentStore","get","getMultiple","ids","getAll","remove","rawDocument","createDocumentsStore","AVAILABLE_PLUGIN_HOOKS","getAllPluginsByHook","hook","_orama_plugins","pluginsToRun","pluginsLength","plugin","OBJECT_COMPONENTS","FUNCTION_COMPONENTS","runAfterSearch","hooks","db","params","language","results","hooksLength","runBeforeSearch","rotateLeft","node","right","getHeight","rotateRight","left","rangeSearch","min","max","traverse","greaterThan","inclusive","lessThan","getNodeByKey","insert","rootNode","newValue","insertNode","balanceFactor","find","root","parentNode","minValueNode","minValueParent","childNode","removeDocument","_root_numberToDocumentId_get","_root_numberToDocumentId_get1","v","filter","operation","operationKeys","operationType","keys","filterArr","_boundedLevenshtein","tolerance","swap","lenA","lenB","startIdx","delta","row","characterCodeCache","offset","haveMax","jStart","jEnd","above","charA","syncBoundedLevenshtein","Node","subWord","end","__publicField","updateParent","parent","addDocument","docID","index","findAllWords","output","term","exact","docIDs","docs","docIDsLength","character","getCommonPrefix","commonPrefix","len","word","docId","wordLength","currentCharacter","wordAtIndex","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","_findLevenshtein","originalTolerance","termLength","termSubstring","removeDocumentByWord","K","EARTH_RADIUS","tree","point","depth","newDocIDs","removeDocByID","direction","_node_docIDs","_node_docIDs1","axis","searchByRadius","center","radius","sort","highPrecision","distanceFn","vincentyDistance","haversineDistance","stack","dist","distA","distB","searchByPolygon","polygon","task","nextDepth","isInsidePolygon","isPointInPolygon","centroid","calculatePolygonCentroid","sortFn","totalArea","centroidX","centroidY","polygonLength","xi","yi","xj","yj","areaSegment","centroidCoordinate","isInside","x","y","coord1","coord2","P","lat1","lat2","deltaLat","deltaLon","c","f","U1","U2","sinU1","cosU1","sinU2","cosU2","lambda","prevLambda","iterationLimit","sinAlpha","cos2Alpha","sinSigma","cosSigma","sigma","sinLambda","cosLambda","cos2SigmaM","C","u2","B","deltaSigma","prioritizeTokenScores","boost","threshold","keywordsCount","tokenScoresMap","tokenKeywordsCountMap","mapsLength","entriesLength","token","score","boostScore","oldScore","tokenScores","tokenScoreEntry","allResults","tokenKeywordsCount","tokenKeywordsCountEntry","keywordsPerToken","lastTokenWithAllKeywords","thresholdLength","BM25","tf","matchingCount","docsCount","fieldLength","averageFieldLength","BM25Params","k","d","getMagnitude","vector","vectorLength","magnitude","findSimilarVectors","targetVector","vectors","length","targetMagnitude","similarVectors","vectorId","dotProduct","similarity","insertDocumentScoreParameters","tokens","insertTokenScoreParameters","tokenFrequency","t","removeDocumentScoreParameters","removeTokenScoreParameters","calculateResultScores","context","documentIDs","avgFieldLength","fieldLengths","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","_oramaFrequencies_internalId","bm25","prefix","isArray","avlCreate","radixCreate","flatCreate","bkdCreate","insertScalar","implementation","schemaType","tokenizer","avlInsert","radixInsert","flatInsert","bkdInsert","insertVector","innerSchemaType","elements","elementsLength","removeScalar","avlRemoveDocument","radixRemoveDocument","flatRemoveDocument","bkdRemoveDocByID","search","radixFind","searchByWhereClause","filters","filterKeys","filtersMap","param","filteredIDs","reqOperation","coordinates","inside","distanceInMeters","filteredIDsResults","flatFilterArr","flatFilter","operationOpt","operationValue","avlGreaterThan","avlLessThan","avlFind","avlRangeSearch","getSearchableProperties","getSearchablePropertiesWithTypes","loadRadixNode","convertedNode","childrenKey","loadFlatNode","saveFlatNode","rawIndexes","rawVectorIndexes","searchableProperties","searchablePropertiesWithTypes","frequencies","tokenOccurrences","indexes","vectorIndexes","idx","vec","vectorIndexesAsArrays","savedIndexes","name","createIndex","innerCreate","sortableDeniedProperties","sorter","ret","config","s","ensureIsSorted","ensurePropertyIsSorted","stringSort","numberSort","booleanSort","predicate","orderedDocsLength","ensureOrderedDocsAreDeleted","ensureOrderedDocsAreDeletedByProperty","sortBy","docIds","by","isDesc","indexOfA","indexOfB","isAIndexed","isBIndexed","getSortableProperties","getSortablePropertiesWithTypes","sorts","orderedDocs","createSorter","DIACRITICS_CHARCODE_START","DIACRITICS_CHARCODE_END","CHARCODE_REPLACE_MAPPING","replaceChar","charCode","replaceDiacritics","str","stringCharCode","step2List","step3List","mgr0","meq1","mgr1","s_v","stemmer","stem","suffix","re","re2","re3","re4","firstch","fp","normalizeToken","_this_stopWords","trim","text","tokenize","input","splitRule","trimTokens","createTokenizer","english","stopWords","validateComponents","components","defaultComponents","rawKey","plugins","documentsStore","internalDocumentStore","MODE_FULLTEXT_SEARCH","MODE_HYBRID_SEARCH","MODE_VECTOR_SEARCH","intersectFilteredIDs","filtered","lookedUp","map","sortingPredicate","order","getFacets","facetsConfig","facets","allIDs","allDocs","facetKeys","facet","values","ranges","range","allDocsLength","facetValue","propertyType","calculateNumberFacet","alreadyInsertedValues","calculateBooleanStringOrEnumFacet","innerType","stringFacetDefinition","DEFAULT_REDUCE","res","ALLOWED_TYPES","getGroups","groupBy","propertiesLength","schemaProperties","returnedCount","listOfValues","g","groupByKey","group","keyValue","combinations","calculateCombination","combinationsLength","combination","combinationLength","groupsLength","reduce","func","initialValue","aggregationValue","arrs","item","head","fullTextSearch","timeStart","defaultBM25Params","shouldCalculateFacets","limit","distinctOn","includeVectors","isPreflight","propertiesToSearch","propertiesToSearchWithTypes","createSearchContext","hasFilters","whereFiltersIDs","tokensLength","indexesLength","_params_boost","vals","uniqueDocs","uniqueDocsLength","prevScore","uniqueDocsArray","docsWithIdAndScore","fetchDocumentsWithDistinct","fetchDocuments","searchVector","vectorIndex","oramaDocs","facetsResults","newDoc","elapsedTime","hybridSearch","fullTextIDs","vectorIDs","getFullTextSearchIDs","getVectorSearchIDs","uniqueTokenScores","mergeAndRankResults","timeEnd","returningResults","uniqueIDs","minMaxScoreNormalization","maxScore","normalizeScore","hybridScore","textScore","vectorScore","textWeight","vectorWeight","textResults","vectorResults","query","maxTextScore","maxVectorScore","getQueryWeights","mergedResults","textResultsLength","normalizedScore","hybridScoreValue","vectorResultsLength","existingRes","indexMap","docsIntersection","tokensMap","mode","resultIDs","uniqueDocsArrayLength","idAndScore","fullDoc","defaultHtmlSchema","customRestore","data","JSONIndex","ev","searchParams"],"mappings":"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ACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,E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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]}